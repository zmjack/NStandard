<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated/>
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using static NStandard.Measures.<#=_class#>;

namespace NStandard.Measures;

#pragma warning disable CS8981 // The type name only contains lower-cased ascii characters. Such names may become reserved for the language.
public static class <#=_class#>
{
<#
    foreach(var pair in _dict)
    {
        var key = pair.Key;
        var div = pair.Value;
#>
	public struct <#=key#> : IMeasurable<<#=_underlyingType#>>
	{
		public <#=_underlyingType#> Value { get; set; }

        public <#=key#>(<#=_underlyingType#> value) => Value = value;
<#
    foreach(var type in _numberTypes)
    {
#>
        public <#=key#>(<#=type#> value) => Value = (<#=_underlyingType#>)value;
<#
    }
#>

		public static <#=key#> operator +(<#=key#> left, <#=key#> right) => new(left.Value + right.Value);
		public static <#=key#> operator -(<#=key#> left, <#=key#> right) => new(left.Value - right.Value);
		public static <#=key#> operator *(<#=key#> left, <#=_underlyingType#> right) => new(left.Value * right);
		public static <#=key#> operator /(<#=key#> left, <#=_underlyingType#> right) => new(left.Value / right);
		public static <#=key#> operator /(<#=key#> left, <#=key#> right) => left.Value / right.Value;
        
		public static bool operator ==(<#=key#> left, <#=key#> right) => left.Value == right.Value;
		public static bool operator !=(<#=key#> left, <#=key#> right) => left.Value != right.Value;
		public static bool operator <(<#=key#> left, <#=key#> right) => left.Value < right.Value;
		public static bool operator <=(<#=key#> left, <#=key#> right) => left.Value <= right.Value;
		public static bool operator >(<#=key#> left, <#=key#> right) => left.Value > right.Value;
		public static bool operator >=(<#=key#> left, <#=key#> right) => left.Value >= right.Value;
        
<#
    foreach(var _pair in _dict)
    {
        if (key == _pair.Key) continue;

        var other = _pair.Key;
        var mul = _pair.Value;
#>
<#
        if (mul >= div)
        {
#>
		public static explicit operator <#=key#>(<#=other#> other) => new(other.Value * <#=mul / div#>);
<#
        }
        else
        {
#>
		public static explicit operator <#=key#>(<#=other#> other) => new(other.Value / <#=div / mul#>);
<#
        }
    }
#>
        public static implicit operator <#=key#>(<#=_underlyingType#> value) => new <#=key#>(value);
<#
    foreach(var type in _numberTypes)
    {
#>
        public static implicit operator <#=key#>(<#=type#> value) => new((<#=_underlyingType#>)value);
<#
    }
#>

        public override bool Equals(object obj)
        {
            if (obj is not <#=key#> other) return false;
            return Value == other.Value;
        }
        public override int GetHashCode() => (int)(Value % int.MaxValue);
		public override string ToString() => $"{Value} <#=key.ToLower()#>";
	}

<#
    }
#>
}

[EditorBrowsable(EditorBrowsableState.Never)]
public static class <#=_class#>Extensions
{
<#
    foreach(var pair in _dict)
    {
        var key = pair.Key;
        var div = pair.Value;
#>
    public static <#=key#> Sum(this IEnumerable<<#=key#>> @this) => new <#=key#>(@this.Sum(x => x.Value));
    public static <#=key#> Average(this IEnumerable<<#=key#>> @this) => new <#=key#>(@this.Average(x => x.Value));

<#
    }
#>
}
#pragma warning restore CS8981 // The type name only contains lower-cased ascii characters. Such names may become reserved for the language.

<#+
private readonly string _class = "StorageCapacity";
private readonly string _underlyingType = "decimal";
private readonly string[] _numberTypes = ["short", "int", "long", "ushort", "uint", "ulong", "float", "double"];

private readonly Dictionary<string, long> _dict = new()
{
    ["b"] = 1,
    ["kb"] = 1024,
    ["mb"] = (long)1024 * 1024,
    ["gb"] = (long)1024 * 1024 * 1024,
    ["tb"] = (long)1024 * 1024 * 1024 * 1024,
    ["pb"] = (long)1024 * 1024 * 1024 * 1024 * 1024,

    ["B"] = 8,
    ["KB"] = (long)8 * 1024,
    ["MB"] = (long)8 * 1024 * 1024,
    ["GB"] = (long)8 * 1024 * 1024 * 1024,
    ["TB"] = (long)8 * 1024 * 1024 * 1024 * 1024,
    ["PB"] = (long)8 * 1024 * 1024 * 1024 * 1024 * 1024,
};
#>