// <auto-generated/>
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using static NStandard.Measures.StorageCapacity;

namespace NStandard.Measures;

#pragma warning disable CS8981 // The type name only contains lower-cased ascii characters. Such names may become reserved for the language.
public static class StorageCapacity
{
	public struct b : IMeasurable<decimal>
	{
		public decimal Value { get; set; }

        public b(decimal value) => Value = value;
        public b(short value) => Value = (decimal)value;
        public b(int value) => Value = (decimal)value;
        public b(long value) => Value = (decimal)value;
        public b(ushort value) => Value = (decimal)value;
        public b(uint value) => Value = (decimal)value;
        public b(ulong value) => Value = (decimal)value;
        public b(float value) => Value = (decimal)value;
        public b(double value) => Value = (decimal)value;

		public static b operator +(b left, b right) => new(left.Value + right.Value);
		public static b operator -(b left, b right) => new(left.Value - right.Value);
		public static b operator *(b left, decimal right) => new(left.Value * right);
		public static b operator /(b left, decimal right) => new(left.Value / right);
		public static b operator /(b left, b right) => left.Value / right.Value;
        
		public static bool operator ==(b left, b right) => left.Value == right.Value;
		public static bool operator !=(b left, b right) => left.Value != right.Value;
		public static bool operator <(b left, b right) => left.Value < right.Value;
		public static bool operator <=(b left, b right) => left.Value <= right.Value;
		public static bool operator >(b left, b right) => left.Value > right.Value;
		public static bool operator >=(b left, b right) => left.Value >= right.Value;
        
		public static explicit operator b(kb other) => new(other.Value * 1024);
		public static explicit operator b(mb other) => new(other.Value * 1048576);
		public static explicit operator b(gb other) => new(other.Value * 1073741824);
		public static explicit operator b(tb other) => new(other.Value * 1099511627776);
		public static explicit operator b(pb other) => new(other.Value * 1125899906842624);
		public static explicit operator b(B other) => new(other.Value * 8);
		public static explicit operator b(KB other) => new(other.Value * 8192);
		public static explicit operator b(MB other) => new(other.Value * 8388608);
		public static explicit operator b(GB other) => new(other.Value * 8589934592);
		public static explicit operator b(TB other) => new(other.Value * 8796093022208);
		public static explicit operator b(PB other) => new(other.Value * 9007199254740992);
        public static implicit operator b(decimal value) => new b(value);
        public static implicit operator b(short value) => new((decimal)value);
        public static implicit operator b(int value) => new((decimal)value);
        public static implicit operator b(long value) => new((decimal)value);
        public static implicit operator b(ushort value) => new((decimal)value);
        public static implicit operator b(uint value) => new((decimal)value);
        public static implicit operator b(ulong value) => new((decimal)value);
        public static implicit operator b(float value) => new((decimal)value);
        public static implicit operator b(double value) => new((decimal)value);

        public override bool Equals(object obj)
        {
            if (obj is not b other) return false;
            return Value == other.Value;
        }
        public override int GetHashCode() => (int)(Value % int.MaxValue);
		public override string ToString() => $"{Value} b";
	}

	public struct kb : IMeasurable<decimal>
	{
		public decimal Value { get; set; }

        public kb(decimal value) => Value = value;
        public kb(short value) => Value = (decimal)value;
        public kb(int value) => Value = (decimal)value;
        public kb(long value) => Value = (decimal)value;
        public kb(ushort value) => Value = (decimal)value;
        public kb(uint value) => Value = (decimal)value;
        public kb(ulong value) => Value = (decimal)value;
        public kb(float value) => Value = (decimal)value;
        public kb(double value) => Value = (decimal)value;

		public static kb operator +(kb left, kb right) => new(left.Value + right.Value);
		public static kb operator -(kb left, kb right) => new(left.Value - right.Value);
		public static kb operator *(kb left, decimal right) => new(left.Value * right);
		public static kb operator /(kb left, decimal right) => new(left.Value / right);
		public static kb operator /(kb left, kb right) => left.Value / right.Value;
        
		public static bool operator ==(kb left, kb right) => left.Value == right.Value;
		public static bool operator !=(kb left, kb right) => left.Value != right.Value;
		public static bool operator <(kb left, kb right) => left.Value < right.Value;
		public static bool operator <=(kb left, kb right) => left.Value <= right.Value;
		public static bool operator >(kb left, kb right) => left.Value > right.Value;
		public static bool operator >=(kb left, kb right) => left.Value >= right.Value;
        
		public static explicit operator kb(b other) => new(other.Value / 1024);
		public static explicit operator kb(mb other) => new(other.Value * 1024);
		public static explicit operator kb(gb other) => new(other.Value * 1048576);
		public static explicit operator kb(tb other) => new(other.Value * 1073741824);
		public static explicit operator kb(pb other) => new(other.Value * 1099511627776);
		public static explicit operator kb(B other) => new(other.Value / 128);
		public static explicit operator kb(KB other) => new(other.Value * 8);
		public static explicit operator kb(MB other) => new(other.Value * 8192);
		public static explicit operator kb(GB other) => new(other.Value * 8388608);
		public static explicit operator kb(TB other) => new(other.Value * 8589934592);
		public static explicit operator kb(PB other) => new(other.Value * 8796093022208);
        public static implicit operator kb(decimal value) => new kb(value);
        public static implicit operator kb(short value) => new((decimal)value);
        public static implicit operator kb(int value) => new((decimal)value);
        public static implicit operator kb(long value) => new((decimal)value);
        public static implicit operator kb(ushort value) => new((decimal)value);
        public static implicit operator kb(uint value) => new((decimal)value);
        public static implicit operator kb(ulong value) => new((decimal)value);
        public static implicit operator kb(float value) => new((decimal)value);
        public static implicit operator kb(double value) => new((decimal)value);

        public override bool Equals(object obj)
        {
            if (obj is not kb other) return false;
            return Value == other.Value;
        }
        public override int GetHashCode() => (int)(Value % int.MaxValue);
		public override string ToString() => $"{Value} kb";
	}

	public struct mb : IMeasurable<decimal>
	{
		public decimal Value { get; set; }

        public mb(decimal value) => Value = value;
        public mb(short value) => Value = (decimal)value;
        public mb(int value) => Value = (decimal)value;
        public mb(long value) => Value = (decimal)value;
        public mb(ushort value) => Value = (decimal)value;
        public mb(uint value) => Value = (decimal)value;
        public mb(ulong value) => Value = (decimal)value;
        public mb(float value) => Value = (decimal)value;
        public mb(double value) => Value = (decimal)value;

		public static mb operator +(mb left, mb right) => new(left.Value + right.Value);
		public static mb operator -(mb left, mb right) => new(left.Value - right.Value);
		public static mb operator *(mb left, decimal right) => new(left.Value * right);
		public static mb operator /(mb left, decimal right) => new(left.Value / right);
		public static mb operator /(mb left, mb right) => left.Value / right.Value;
        
		public static bool operator ==(mb left, mb right) => left.Value == right.Value;
		public static bool operator !=(mb left, mb right) => left.Value != right.Value;
		public static bool operator <(mb left, mb right) => left.Value < right.Value;
		public static bool operator <=(mb left, mb right) => left.Value <= right.Value;
		public static bool operator >(mb left, mb right) => left.Value > right.Value;
		public static bool operator >=(mb left, mb right) => left.Value >= right.Value;
        
		public static explicit operator mb(b other) => new(other.Value / 1048576);
		public static explicit operator mb(kb other) => new(other.Value / 1024);
		public static explicit operator mb(gb other) => new(other.Value * 1024);
		public static explicit operator mb(tb other) => new(other.Value * 1048576);
		public static explicit operator mb(pb other) => new(other.Value * 1073741824);
		public static explicit operator mb(B other) => new(other.Value / 131072);
		public static explicit operator mb(KB other) => new(other.Value / 128);
		public static explicit operator mb(MB other) => new(other.Value * 8);
		public static explicit operator mb(GB other) => new(other.Value * 8192);
		public static explicit operator mb(TB other) => new(other.Value * 8388608);
		public static explicit operator mb(PB other) => new(other.Value * 8589934592);
        public static implicit operator mb(decimal value) => new mb(value);
        public static implicit operator mb(short value) => new((decimal)value);
        public static implicit operator mb(int value) => new((decimal)value);
        public static implicit operator mb(long value) => new((decimal)value);
        public static implicit operator mb(ushort value) => new((decimal)value);
        public static implicit operator mb(uint value) => new((decimal)value);
        public static implicit operator mb(ulong value) => new((decimal)value);
        public static implicit operator mb(float value) => new((decimal)value);
        public static implicit operator mb(double value) => new((decimal)value);

        public override bool Equals(object obj)
        {
            if (obj is not mb other) return false;
            return Value == other.Value;
        }
        public override int GetHashCode() => (int)(Value % int.MaxValue);
		public override string ToString() => $"{Value} mb";
	}

	public struct gb : IMeasurable<decimal>
	{
		public decimal Value { get; set; }

        public gb(decimal value) => Value = value;
        public gb(short value) => Value = (decimal)value;
        public gb(int value) => Value = (decimal)value;
        public gb(long value) => Value = (decimal)value;
        public gb(ushort value) => Value = (decimal)value;
        public gb(uint value) => Value = (decimal)value;
        public gb(ulong value) => Value = (decimal)value;
        public gb(float value) => Value = (decimal)value;
        public gb(double value) => Value = (decimal)value;

		public static gb operator +(gb left, gb right) => new(left.Value + right.Value);
		public static gb operator -(gb left, gb right) => new(left.Value - right.Value);
		public static gb operator *(gb left, decimal right) => new(left.Value * right);
		public static gb operator /(gb left, decimal right) => new(left.Value / right);
		public static gb operator /(gb left, gb right) => left.Value / right.Value;
        
		public static bool operator ==(gb left, gb right) => left.Value == right.Value;
		public static bool operator !=(gb left, gb right) => left.Value != right.Value;
		public static bool operator <(gb left, gb right) => left.Value < right.Value;
		public static bool operator <=(gb left, gb right) => left.Value <= right.Value;
		public static bool operator >(gb left, gb right) => left.Value > right.Value;
		public static bool operator >=(gb left, gb right) => left.Value >= right.Value;
        
		public static explicit operator gb(b other) => new(other.Value / 1073741824);
		public static explicit operator gb(kb other) => new(other.Value / 1048576);
		public static explicit operator gb(mb other) => new(other.Value / 1024);
		public static explicit operator gb(tb other) => new(other.Value * 1024);
		public static explicit operator gb(pb other) => new(other.Value * 1048576);
		public static explicit operator gb(B other) => new(other.Value / 134217728);
		public static explicit operator gb(KB other) => new(other.Value / 131072);
		public static explicit operator gb(MB other) => new(other.Value / 128);
		public static explicit operator gb(GB other) => new(other.Value * 8);
		public static explicit operator gb(TB other) => new(other.Value * 8192);
		public static explicit operator gb(PB other) => new(other.Value * 8388608);
        public static implicit operator gb(decimal value) => new gb(value);
        public static implicit operator gb(short value) => new((decimal)value);
        public static implicit operator gb(int value) => new((decimal)value);
        public static implicit operator gb(long value) => new((decimal)value);
        public static implicit operator gb(ushort value) => new((decimal)value);
        public static implicit operator gb(uint value) => new((decimal)value);
        public static implicit operator gb(ulong value) => new((decimal)value);
        public static implicit operator gb(float value) => new((decimal)value);
        public static implicit operator gb(double value) => new((decimal)value);

        public override bool Equals(object obj)
        {
            if (obj is not gb other) return false;
            return Value == other.Value;
        }
        public override int GetHashCode() => (int)(Value % int.MaxValue);
		public override string ToString() => $"{Value} gb";
	}

	public struct tb : IMeasurable<decimal>
	{
		public decimal Value { get; set; }

        public tb(decimal value) => Value = value;
        public tb(short value) => Value = (decimal)value;
        public tb(int value) => Value = (decimal)value;
        public tb(long value) => Value = (decimal)value;
        public tb(ushort value) => Value = (decimal)value;
        public tb(uint value) => Value = (decimal)value;
        public tb(ulong value) => Value = (decimal)value;
        public tb(float value) => Value = (decimal)value;
        public tb(double value) => Value = (decimal)value;

		public static tb operator +(tb left, tb right) => new(left.Value + right.Value);
		public static tb operator -(tb left, tb right) => new(left.Value - right.Value);
		public static tb operator *(tb left, decimal right) => new(left.Value * right);
		public static tb operator /(tb left, decimal right) => new(left.Value / right);
		public static tb operator /(tb left, tb right) => left.Value / right.Value;
        
		public static bool operator ==(tb left, tb right) => left.Value == right.Value;
		public static bool operator !=(tb left, tb right) => left.Value != right.Value;
		public static bool operator <(tb left, tb right) => left.Value < right.Value;
		public static bool operator <=(tb left, tb right) => left.Value <= right.Value;
		public static bool operator >(tb left, tb right) => left.Value > right.Value;
		public static bool operator >=(tb left, tb right) => left.Value >= right.Value;
        
		public static explicit operator tb(b other) => new(other.Value / 1099511627776);
		public static explicit operator tb(kb other) => new(other.Value / 1073741824);
		public static explicit operator tb(mb other) => new(other.Value / 1048576);
		public static explicit operator tb(gb other) => new(other.Value / 1024);
		public static explicit operator tb(pb other) => new(other.Value * 1024);
		public static explicit operator tb(B other) => new(other.Value / 137438953472);
		public static explicit operator tb(KB other) => new(other.Value / 134217728);
		public static explicit operator tb(MB other) => new(other.Value / 131072);
		public static explicit operator tb(GB other) => new(other.Value / 128);
		public static explicit operator tb(TB other) => new(other.Value * 8);
		public static explicit operator tb(PB other) => new(other.Value * 8192);
        public static implicit operator tb(decimal value) => new tb(value);
        public static implicit operator tb(short value) => new((decimal)value);
        public static implicit operator tb(int value) => new((decimal)value);
        public static implicit operator tb(long value) => new((decimal)value);
        public static implicit operator tb(ushort value) => new((decimal)value);
        public static implicit operator tb(uint value) => new((decimal)value);
        public static implicit operator tb(ulong value) => new((decimal)value);
        public static implicit operator tb(float value) => new((decimal)value);
        public static implicit operator tb(double value) => new((decimal)value);

        public override bool Equals(object obj)
        {
            if (obj is not tb other) return false;
            return Value == other.Value;
        }
        public override int GetHashCode() => (int)(Value % int.MaxValue);
		public override string ToString() => $"{Value} tb";
	}

	public struct pb : IMeasurable<decimal>
	{
		public decimal Value { get; set; }

        public pb(decimal value) => Value = value;
        public pb(short value) => Value = (decimal)value;
        public pb(int value) => Value = (decimal)value;
        public pb(long value) => Value = (decimal)value;
        public pb(ushort value) => Value = (decimal)value;
        public pb(uint value) => Value = (decimal)value;
        public pb(ulong value) => Value = (decimal)value;
        public pb(float value) => Value = (decimal)value;
        public pb(double value) => Value = (decimal)value;

		public static pb operator +(pb left, pb right) => new(left.Value + right.Value);
		public static pb operator -(pb left, pb right) => new(left.Value - right.Value);
		public static pb operator *(pb left, decimal right) => new(left.Value * right);
		public static pb operator /(pb left, decimal right) => new(left.Value / right);
		public static pb operator /(pb left, pb right) => left.Value / right.Value;
        
		public static bool operator ==(pb left, pb right) => left.Value == right.Value;
		public static bool operator !=(pb left, pb right) => left.Value != right.Value;
		public static bool operator <(pb left, pb right) => left.Value < right.Value;
		public static bool operator <=(pb left, pb right) => left.Value <= right.Value;
		public static bool operator >(pb left, pb right) => left.Value > right.Value;
		public static bool operator >=(pb left, pb right) => left.Value >= right.Value;
        
		public static explicit operator pb(b other) => new(other.Value / 1125899906842624);
		public static explicit operator pb(kb other) => new(other.Value / 1099511627776);
		public static explicit operator pb(mb other) => new(other.Value / 1073741824);
		public static explicit operator pb(gb other) => new(other.Value / 1048576);
		public static explicit operator pb(tb other) => new(other.Value / 1024);
		public static explicit operator pb(B other) => new(other.Value / 140737488355328);
		public static explicit operator pb(KB other) => new(other.Value / 137438953472);
		public static explicit operator pb(MB other) => new(other.Value / 134217728);
		public static explicit operator pb(GB other) => new(other.Value / 131072);
		public static explicit operator pb(TB other) => new(other.Value / 128);
		public static explicit operator pb(PB other) => new(other.Value * 8);
        public static implicit operator pb(decimal value) => new pb(value);
        public static implicit operator pb(short value) => new((decimal)value);
        public static implicit operator pb(int value) => new((decimal)value);
        public static implicit operator pb(long value) => new((decimal)value);
        public static implicit operator pb(ushort value) => new((decimal)value);
        public static implicit operator pb(uint value) => new((decimal)value);
        public static implicit operator pb(ulong value) => new((decimal)value);
        public static implicit operator pb(float value) => new((decimal)value);
        public static implicit operator pb(double value) => new((decimal)value);

        public override bool Equals(object obj)
        {
            if (obj is not pb other) return false;
            return Value == other.Value;
        }
        public override int GetHashCode() => (int)(Value % int.MaxValue);
		public override string ToString() => $"{Value} pb";
	}

	public struct B : IMeasurable<decimal>
	{
		public decimal Value { get; set; }

        public B(decimal value) => Value = value;
        public B(short value) => Value = (decimal)value;
        public B(int value) => Value = (decimal)value;
        public B(long value) => Value = (decimal)value;
        public B(ushort value) => Value = (decimal)value;
        public B(uint value) => Value = (decimal)value;
        public B(ulong value) => Value = (decimal)value;
        public B(float value) => Value = (decimal)value;
        public B(double value) => Value = (decimal)value;

		public static B operator +(B left, B right) => new(left.Value + right.Value);
		public static B operator -(B left, B right) => new(left.Value - right.Value);
		public static B operator *(B left, decimal right) => new(left.Value * right);
		public static B operator /(B left, decimal right) => new(left.Value / right);
		public static B operator /(B left, B right) => left.Value / right.Value;
        
		public static bool operator ==(B left, B right) => left.Value == right.Value;
		public static bool operator !=(B left, B right) => left.Value != right.Value;
		public static bool operator <(B left, B right) => left.Value < right.Value;
		public static bool operator <=(B left, B right) => left.Value <= right.Value;
		public static bool operator >(B left, B right) => left.Value > right.Value;
		public static bool operator >=(B left, B right) => left.Value >= right.Value;
        
		public static explicit operator B(b other) => new(other.Value / 8);
		public static explicit operator B(kb other) => new(other.Value * 128);
		public static explicit operator B(mb other) => new(other.Value * 131072);
		public static explicit operator B(gb other) => new(other.Value * 134217728);
		public static explicit operator B(tb other) => new(other.Value * 137438953472);
		public static explicit operator B(pb other) => new(other.Value * 140737488355328);
		public static explicit operator B(KB other) => new(other.Value * 1024);
		public static explicit operator B(MB other) => new(other.Value * 1048576);
		public static explicit operator B(GB other) => new(other.Value * 1073741824);
		public static explicit operator B(TB other) => new(other.Value * 1099511627776);
		public static explicit operator B(PB other) => new(other.Value * 1125899906842624);
        public static implicit operator B(decimal value) => new B(value);
        public static implicit operator B(short value) => new((decimal)value);
        public static implicit operator B(int value) => new((decimal)value);
        public static implicit operator B(long value) => new((decimal)value);
        public static implicit operator B(ushort value) => new((decimal)value);
        public static implicit operator B(uint value) => new((decimal)value);
        public static implicit operator B(ulong value) => new((decimal)value);
        public static implicit operator B(float value) => new((decimal)value);
        public static implicit operator B(double value) => new((decimal)value);

        public override bool Equals(object obj)
        {
            if (obj is not B other) return false;
            return Value == other.Value;
        }
        public override int GetHashCode() => (int)(Value % int.MaxValue);
		public override string ToString() => $"{Value} b";
	}

	public struct KB : IMeasurable<decimal>
	{
		public decimal Value { get; set; }

        public KB(decimal value) => Value = value;
        public KB(short value) => Value = (decimal)value;
        public KB(int value) => Value = (decimal)value;
        public KB(long value) => Value = (decimal)value;
        public KB(ushort value) => Value = (decimal)value;
        public KB(uint value) => Value = (decimal)value;
        public KB(ulong value) => Value = (decimal)value;
        public KB(float value) => Value = (decimal)value;
        public KB(double value) => Value = (decimal)value;

		public static KB operator +(KB left, KB right) => new(left.Value + right.Value);
		public static KB operator -(KB left, KB right) => new(left.Value - right.Value);
		public static KB operator *(KB left, decimal right) => new(left.Value * right);
		public static KB operator /(KB left, decimal right) => new(left.Value / right);
		public static KB operator /(KB left, KB right) => left.Value / right.Value;
        
		public static bool operator ==(KB left, KB right) => left.Value == right.Value;
		public static bool operator !=(KB left, KB right) => left.Value != right.Value;
		public static bool operator <(KB left, KB right) => left.Value < right.Value;
		public static bool operator <=(KB left, KB right) => left.Value <= right.Value;
		public static bool operator >(KB left, KB right) => left.Value > right.Value;
		public static bool operator >=(KB left, KB right) => left.Value >= right.Value;
        
		public static explicit operator KB(b other) => new(other.Value / 8192);
		public static explicit operator KB(kb other) => new(other.Value / 8);
		public static explicit operator KB(mb other) => new(other.Value * 128);
		public static explicit operator KB(gb other) => new(other.Value * 131072);
		public static explicit operator KB(tb other) => new(other.Value * 134217728);
		public static explicit operator KB(pb other) => new(other.Value * 137438953472);
		public static explicit operator KB(B other) => new(other.Value / 1024);
		public static explicit operator KB(MB other) => new(other.Value * 1024);
		public static explicit operator KB(GB other) => new(other.Value * 1048576);
		public static explicit operator KB(TB other) => new(other.Value * 1073741824);
		public static explicit operator KB(PB other) => new(other.Value * 1099511627776);
        public static implicit operator KB(decimal value) => new KB(value);
        public static implicit operator KB(short value) => new((decimal)value);
        public static implicit operator KB(int value) => new((decimal)value);
        public static implicit operator KB(long value) => new((decimal)value);
        public static implicit operator KB(ushort value) => new((decimal)value);
        public static implicit operator KB(uint value) => new((decimal)value);
        public static implicit operator KB(ulong value) => new((decimal)value);
        public static implicit operator KB(float value) => new((decimal)value);
        public static implicit operator KB(double value) => new((decimal)value);

        public override bool Equals(object obj)
        {
            if (obj is not KB other) return false;
            return Value == other.Value;
        }
        public override int GetHashCode() => (int)(Value % int.MaxValue);
		public override string ToString() => $"{Value} kb";
	}

	public struct MB : IMeasurable<decimal>
	{
		public decimal Value { get; set; }

        public MB(decimal value) => Value = value;
        public MB(short value) => Value = (decimal)value;
        public MB(int value) => Value = (decimal)value;
        public MB(long value) => Value = (decimal)value;
        public MB(ushort value) => Value = (decimal)value;
        public MB(uint value) => Value = (decimal)value;
        public MB(ulong value) => Value = (decimal)value;
        public MB(float value) => Value = (decimal)value;
        public MB(double value) => Value = (decimal)value;

		public static MB operator +(MB left, MB right) => new(left.Value + right.Value);
		public static MB operator -(MB left, MB right) => new(left.Value - right.Value);
		public static MB operator *(MB left, decimal right) => new(left.Value * right);
		public static MB operator /(MB left, decimal right) => new(left.Value / right);
		public static MB operator /(MB left, MB right) => left.Value / right.Value;
        
		public static bool operator ==(MB left, MB right) => left.Value == right.Value;
		public static bool operator !=(MB left, MB right) => left.Value != right.Value;
		public static bool operator <(MB left, MB right) => left.Value < right.Value;
		public static bool operator <=(MB left, MB right) => left.Value <= right.Value;
		public static bool operator >(MB left, MB right) => left.Value > right.Value;
		public static bool operator >=(MB left, MB right) => left.Value >= right.Value;
        
		public static explicit operator MB(b other) => new(other.Value / 8388608);
		public static explicit operator MB(kb other) => new(other.Value / 8192);
		public static explicit operator MB(mb other) => new(other.Value / 8);
		public static explicit operator MB(gb other) => new(other.Value * 128);
		public static explicit operator MB(tb other) => new(other.Value * 131072);
		public static explicit operator MB(pb other) => new(other.Value * 134217728);
		public static explicit operator MB(B other) => new(other.Value / 1048576);
		public static explicit operator MB(KB other) => new(other.Value / 1024);
		public static explicit operator MB(GB other) => new(other.Value * 1024);
		public static explicit operator MB(TB other) => new(other.Value * 1048576);
		public static explicit operator MB(PB other) => new(other.Value * 1073741824);
        public static implicit operator MB(decimal value) => new MB(value);
        public static implicit operator MB(short value) => new((decimal)value);
        public static implicit operator MB(int value) => new((decimal)value);
        public static implicit operator MB(long value) => new((decimal)value);
        public static implicit operator MB(ushort value) => new((decimal)value);
        public static implicit operator MB(uint value) => new((decimal)value);
        public static implicit operator MB(ulong value) => new((decimal)value);
        public static implicit operator MB(float value) => new((decimal)value);
        public static implicit operator MB(double value) => new((decimal)value);

        public override bool Equals(object obj)
        {
            if (obj is not MB other) return false;
            return Value == other.Value;
        }
        public override int GetHashCode() => (int)(Value % int.MaxValue);
		public override string ToString() => $"{Value} mb";
	}

	public struct GB : IMeasurable<decimal>
	{
		public decimal Value { get; set; }

        public GB(decimal value) => Value = value;
        public GB(short value) => Value = (decimal)value;
        public GB(int value) => Value = (decimal)value;
        public GB(long value) => Value = (decimal)value;
        public GB(ushort value) => Value = (decimal)value;
        public GB(uint value) => Value = (decimal)value;
        public GB(ulong value) => Value = (decimal)value;
        public GB(float value) => Value = (decimal)value;
        public GB(double value) => Value = (decimal)value;

		public static GB operator +(GB left, GB right) => new(left.Value + right.Value);
		public static GB operator -(GB left, GB right) => new(left.Value - right.Value);
		public static GB operator *(GB left, decimal right) => new(left.Value * right);
		public static GB operator /(GB left, decimal right) => new(left.Value / right);
		public static GB operator /(GB left, GB right) => left.Value / right.Value;
        
		public static bool operator ==(GB left, GB right) => left.Value == right.Value;
		public static bool operator !=(GB left, GB right) => left.Value != right.Value;
		public static bool operator <(GB left, GB right) => left.Value < right.Value;
		public static bool operator <=(GB left, GB right) => left.Value <= right.Value;
		public static bool operator >(GB left, GB right) => left.Value > right.Value;
		public static bool operator >=(GB left, GB right) => left.Value >= right.Value;
        
		public static explicit operator GB(b other) => new(other.Value / 8589934592);
		public static explicit operator GB(kb other) => new(other.Value / 8388608);
		public static explicit operator GB(mb other) => new(other.Value / 8192);
		public static explicit operator GB(gb other) => new(other.Value / 8);
		public static explicit operator GB(tb other) => new(other.Value * 128);
		public static explicit operator GB(pb other) => new(other.Value * 131072);
		public static explicit operator GB(B other) => new(other.Value / 1073741824);
		public static explicit operator GB(KB other) => new(other.Value / 1048576);
		public static explicit operator GB(MB other) => new(other.Value / 1024);
		public static explicit operator GB(TB other) => new(other.Value * 1024);
		public static explicit operator GB(PB other) => new(other.Value * 1048576);
        public static implicit operator GB(decimal value) => new GB(value);
        public static implicit operator GB(short value) => new((decimal)value);
        public static implicit operator GB(int value) => new((decimal)value);
        public static implicit operator GB(long value) => new((decimal)value);
        public static implicit operator GB(ushort value) => new((decimal)value);
        public static implicit operator GB(uint value) => new((decimal)value);
        public static implicit operator GB(ulong value) => new((decimal)value);
        public static implicit operator GB(float value) => new((decimal)value);
        public static implicit operator GB(double value) => new((decimal)value);

        public override bool Equals(object obj)
        {
            if (obj is not GB other) return false;
            return Value == other.Value;
        }
        public override int GetHashCode() => (int)(Value % int.MaxValue);
		public override string ToString() => $"{Value} gb";
	}

	public struct TB : IMeasurable<decimal>
	{
		public decimal Value { get; set; }

        public TB(decimal value) => Value = value;
        public TB(short value) => Value = (decimal)value;
        public TB(int value) => Value = (decimal)value;
        public TB(long value) => Value = (decimal)value;
        public TB(ushort value) => Value = (decimal)value;
        public TB(uint value) => Value = (decimal)value;
        public TB(ulong value) => Value = (decimal)value;
        public TB(float value) => Value = (decimal)value;
        public TB(double value) => Value = (decimal)value;

		public static TB operator +(TB left, TB right) => new(left.Value + right.Value);
		public static TB operator -(TB left, TB right) => new(left.Value - right.Value);
		public static TB operator *(TB left, decimal right) => new(left.Value * right);
		public static TB operator /(TB left, decimal right) => new(left.Value / right);
		public static TB operator /(TB left, TB right) => left.Value / right.Value;
        
		public static bool operator ==(TB left, TB right) => left.Value == right.Value;
		public static bool operator !=(TB left, TB right) => left.Value != right.Value;
		public static bool operator <(TB left, TB right) => left.Value < right.Value;
		public static bool operator <=(TB left, TB right) => left.Value <= right.Value;
		public static bool operator >(TB left, TB right) => left.Value > right.Value;
		public static bool operator >=(TB left, TB right) => left.Value >= right.Value;
        
		public static explicit operator TB(b other) => new(other.Value / 8796093022208);
		public static explicit operator TB(kb other) => new(other.Value / 8589934592);
		public static explicit operator TB(mb other) => new(other.Value / 8388608);
		public static explicit operator TB(gb other) => new(other.Value / 8192);
		public static explicit operator TB(tb other) => new(other.Value / 8);
		public static explicit operator TB(pb other) => new(other.Value * 128);
		public static explicit operator TB(B other) => new(other.Value / 1099511627776);
		public static explicit operator TB(KB other) => new(other.Value / 1073741824);
		public static explicit operator TB(MB other) => new(other.Value / 1048576);
		public static explicit operator TB(GB other) => new(other.Value / 1024);
		public static explicit operator TB(PB other) => new(other.Value * 1024);
        public static implicit operator TB(decimal value) => new TB(value);
        public static implicit operator TB(short value) => new((decimal)value);
        public static implicit operator TB(int value) => new((decimal)value);
        public static implicit operator TB(long value) => new((decimal)value);
        public static implicit operator TB(ushort value) => new((decimal)value);
        public static implicit operator TB(uint value) => new((decimal)value);
        public static implicit operator TB(ulong value) => new((decimal)value);
        public static implicit operator TB(float value) => new((decimal)value);
        public static implicit operator TB(double value) => new((decimal)value);

        public override bool Equals(object obj)
        {
            if (obj is not TB other) return false;
            return Value == other.Value;
        }
        public override int GetHashCode() => (int)(Value % int.MaxValue);
		public override string ToString() => $"{Value} tb";
	}

	public struct PB : IMeasurable<decimal>
	{
		public decimal Value { get; set; }

        public PB(decimal value) => Value = value;
        public PB(short value) => Value = (decimal)value;
        public PB(int value) => Value = (decimal)value;
        public PB(long value) => Value = (decimal)value;
        public PB(ushort value) => Value = (decimal)value;
        public PB(uint value) => Value = (decimal)value;
        public PB(ulong value) => Value = (decimal)value;
        public PB(float value) => Value = (decimal)value;
        public PB(double value) => Value = (decimal)value;

		public static PB operator +(PB left, PB right) => new(left.Value + right.Value);
		public static PB operator -(PB left, PB right) => new(left.Value - right.Value);
		public static PB operator *(PB left, decimal right) => new(left.Value * right);
		public static PB operator /(PB left, decimal right) => new(left.Value / right);
		public static PB operator /(PB left, PB right) => left.Value / right.Value;
        
		public static bool operator ==(PB left, PB right) => left.Value == right.Value;
		public static bool operator !=(PB left, PB right) => left.Value != right.Value;
		public static bool operator <(PB left, PB right) => left.Value < right.Value;
		public static bool operator <=(PB left, PB right) => left.Value <= right.Value;
		public static bool operator >(PB left, PB right) => left.Value > right.Value;
		public static bool operator >=(PB left, PB right) => left.Value >= right.Value;
        
		public static explicit operator PB(b other) => new(other.Value / 9007199254740992);
		public static explicit operator PB(kb other) => new(other.Value / 8796093022208);
		public static explicit operator PB(mb other) => new(other.Value / 8589934592);
		public static explicit operator PB(gb other) => new(other.Value / 8388608);
		public static explicit operator PB(tb other) => new(other.Value / 8192);
		public static explicit operator PB(pb other) => new(other.Value / 8);
		public static explicit operator PB(B other) => new(other.Value / 1125899906842624);
		public static explicit operator PB(KB other) => new(other.Value / 1099511627776);
		public static explicit operator PB(MB other) => new(other.Value / 1073741824);
		public static explicit operator PB(GB other) => new(other.Value / 1048576);
		public static explicit operator PB(TB other) => new(other.Value / 1024);
        public static implicit operator PB(decimal value) => new PB(value);
        public static implicit operator PB(short value) => new((decimal)value);
        public static implicit operator PB(int value) => new((decimal)value);
        public static implicit operator PB(long value) => new((decimal)value);
        public static implicit operator PB(ushort value) => new((decimal)value);
        public static implicit operator PB(uint value) => new((decimal)value);
        public static implicit operator PB(ulong value) => new((decimal)value);
        public static implicit operator PB(float value) => new((decimal)value);
        public static implicit operator PB(double value) => new((decimal)value);

        public override bool Equals(object obj)
        {
            if (obj is not PB other) return false;
            return Value == other.Value;
        }
        public override int GetHashCode() => (int)(Value % int.MaxValue);
		public override string ToString() => $"{Value} pb";
	}

}

[EditorBrowsable(EditorBrowsableState.Never)]
public static class StorageCapacityExtensions
{
    public static b Sum(this IEnumerable<b> @this) => new b(@this.Sum(x => x.Value));
    public static b Average(this IEnumerable<b> @this) => new b(@this.Average(x => x.Value));

    public static kb Sum(this IEnumerable<kb> @this) => new kb(@this.Sum(x => x.Value));
    public static kb Average(this IEnumerable<kb> @this) => new kb(@this.Average(x => x.Value));

    public static mb Sum(this IEnumerable<mb> @this) => new mb(@this.Sum(x => x.Value));
    public static mb Average(this IEnumerable<mb> @this) => new mb(@this.Average(x => x.Value));

    public static gb Sum(this IEnumerable<gb> @this) => new gb(@this.Sum(x => x.Value));
    public static gb Average(this IEnumerable<gb> @this) => new gb(@this.Average(x => x.Value));

    public static tb Sum(this IEnumerable<tb> @this) => new tb(@this.Sum(x => x.Value));
    public static tb Average(this IEnumerable<tb> @this) => new tb(@this.Average(x => x.Value));

    public static pb Sum(this IEnumerable<pb> @this) => new pb(@this.Sum(x => x.Value));
    public static pb Average(this IEnumerable<pb> @this) => new pb(@this.Average(x => x.Value));

    public static B Sum(this IEnumerable<B> @this) => new B(@this.Sum(x => x.Value));
    public static B Average(this IEnumerable<B> @this) => new B(@this.Average(x => x.Value));

    public static KB Sum(this IEnumerable<KB> @this) => new KB(@this.Sum(x => x.Value));
    public static KB Average(this IEnumerable<KB> @this) => new KB(@this.Average(x => x.Value));

    public static MB Sum(this IEnumerable<MB> @this) => new MB(@this.Sum(x => x.Value));
    public static MB Average(this IEnumerable<MB> @this) => new MB(@this.Average(x => x.Value));

    public static GB Sum(this IEnumerable<GB> @this) => new GB(@this.Sum(x => x.Value));
    public static GB Average(this IEnumerable<GB> @this) => new GB(@this.Average(x => x.Value));

    public static TB Sum(this IEnumerable<TB> @this) => new TB(@this.Sum(x => x.Value));
    public static TB Average(this IEnumerable<TB> @this) => new TB(@this.Average(x => x.Value));

    public static PB Sum(this IEnumerable<PB> @this) => new PB(@this.Sum(x => x.Value));
    public static PB Average(this IEnumerable<PB> @this) => new PB(@this.Average(x => x.Value));

}
#pragma warning restore CS8981 // The type name only contains lower-cased ascii characters. Such names may become reserved for the language.

