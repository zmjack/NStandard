// <auto-generated/>
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using static NStandard.Measures.Length;

namespace NStandard.Measures;

public static class Length
{
	public struct mm(double value) : IMeasurable<double>
	{
		public double Value { get; set; } = value;

		public static mm operator +(mm left, mm right) => new(left.Value + right.Value);
		public static mm operator -(mm left, mm right) => new(left.Value - right.Value);
		public static mm operator *(mm left, double right) => new(left.Value * right);
		public static mm operator /(mm left, double right) => new(left.Value / right);
		public static mm operator /(mm left, mm right) => left.Value / right.Value;
        
		public static bool operator ==(mm left, mm right) => left.Value == right.Value;
		public static bool operator !=(mm left, mm right) => left.Value != right.Value;
		public static bool operator <(mm left, mm right) => left.Value < right.Value;
		public static bool operator <=(mm left, mm right) => left.Value <= right.Value;
		public static bool operator >(mm left, mm right) => left.Value > right.Value;
		public static bool operator >=(mm left, mm right) => left.Value >= right.Value;
        
		public static explicit operator mm(cm other) => new(other.Value * 10);
		public static explicit operator mm(dm other) => new(other.Value * 100);
		public static explicit operator mm(m other) => new(other.Value * 1000);
		public static explicit operator mm(km other) => new(other.Value * 1000000);
        public static implicit operator mm(double value) => new mm(value);

		public override string ToString() => $"{Value} mm";
	}

	public struct cm(double value) : IMeasurable<double>
	{
		public double Value { get; set; } = value;

		public static cm operator +(cm left, cm right) => new(left.Value + right.Value);
		public static cm operator -(cm left, cm right) => new(left.Value - right.Value);
		public static cm operator *(cm left, double right) => new(left.Value * right);
		public static cm operator /(cm left, double right) => new(left.Value / right);
		public static cm operator /(cm left, cm right) => left.Value / right.Value;
        
		public static bool operator ==(cm left, cm right) => left.Value == right.Value;
		public static bool operator !=(cm left, cm right) => left.Value != right.Value;
		public static bool operator <(cm left, cm right) => left.Value < right.Value;
		public static bool operator <=(cm left, cm right) => left.Value <= right.Value;
		public static bool operator >(cm left, cm right) => left.Value > right.Value;
		public static bool operator >=(cm left, cm right) => left.Value >= right.Value;
        
		public static explicit operator cm(mm other) => new(other.Value / 10);
		public static explicit operator cm(dm other) => new(other.Value * 10);
		public static explicit operator cm(m other) => new(other.Value * 100);
		public static explicit operator cm(km other) => new(other.Value * 100000);
        public static implicit operator cm(double value) => new cm(value);

		public override string ToString() => $"{Value} cm";
	}

	public struct dm(double value) : IMeasurable<double>
	{
		public double Value { get; set; } = value;

		public static dm operator +(dm left, dm right) => new(left.Value + right.Value);
		public static dm operator -(dm left, dm right) => new(left.Value - right.Value);
		public static dm operator *(dm left, double right) => new(left.Value * right);
		public static dm operator /(dm left, double right) => new(left.Value / right);
		public static dm operator /(dm left, dm right) => left.Value / right.Value;
        
		public static bool operator ==(dm left, dm right) => left.Value == right.Value;
		public static bool operator !=(dm left, dm right) => left.Value != right.Value;
		public static bool operator <(dm left, dm right) => left.Value < right.Value;
		public static bool operator <=(dm left, dm right) => left.Value <= right.Value;
		public static bool operator >(dm left, dm right) => left.Value > right.Value;
		public static bool operator >=(dm left, dm right) => left.Value >= right.Value;
        
		public static explicit operator dm(mm other) => new(other.Value / 100);
		public static explicit operator dm(cm other) => new(other.Value / 10);
		public static explicit operator dm(m other) => new(other.Value * 10);
		public static explicit operator dm(km other) => new(other.Value * 10000);
        public static implicit operator dm(double value) => new dm(value);

		public override string ToString() => $"{Value} dm";
	}

	public struct m(double value) : IMeasurable<double>
	{
		public double Value { get; set; } = value;

		public static m operator +(m left, m right) => new(left.Value + right.Value);
		public static m operator -(m left, m right) => new(left.Value - right.Value);
		public static m operator *(m left, double right) => new(left.Value * right);
		public static m operator /(m left, double right) => new(left.Value / right);
		public static m operator /(m left, m right) => left.Value / right.Value;
        
		public static bool operator ==(m left, m right) => left.Value == right.Value;
		public static bool operator !=(m left, m right) => left.Value != right.Value;
		public static bool operator <(m left, m right) => left.Value < right.Value;
		public static bool operator <=(m left, m right) => left.Value <= right.Value;
		public static bool operator >(m left, m right) => left.Value > right.Value;
		public static bool operator >=(m left, m right) => left.Value >= right.Value;
        
		public static explicit operator m(mm other) => new(other.Value / 1000);
		public static explicit operator m(cm other) => new(other.Value / 100);
		public static explicit operator m(dm other) => new(other.Value / 10);
		public static explicit operator m(km other) => new(other.Value * 1000);
        public static implicit operator m(double value) => new m(value);

		public override string ToString() => $"{Value} m";
	}

	public struct km(double value) : IMeasurable<double>
	{
		public double Value { get; set; } = value;

		public static km operator +(km left, km right) => new(left.Value + right.Value);
		public static km operator -(km left, km right) => new(left.Value - right.Value);
		public static km operator *(km left, double right) => new(left.Value * right);
		public static km operator /(km left, double right) => new(left.Value / right);
		public static km operator /(km left, km right) => left.Value / right.Value;
        
		public static bool operator ==(km left, km right) => left.Value == right.Value;
		public static bool operator !=(km left, km right) => left.Value != right.Value;
		public static bool operator <(km left, km right) => left.Value < right.Value;
		public static bool operator <=(km left, km right) => left.Value <= right.Value;
		public static bool operator >(km left, km right) => left.Value > right.Value;
		public static bool operator >=(km left, km right) => left.Value >= right.Value;
        
		public static explicit operator km(mm other) => new(other.Value / 1000000);
		public static explicit operator km(cm other) => new(other.Value / 100000);
		public static explicit operator km(dm other) => new(other.Value / 10000);
		public static explicit operator km(m other) => new(other.Value / 1000);
        public static implicit operator km(double value) => new km(value);

		public override string ToString() => $"{Value} km";
	}

}

[EditorBrowsable(EditorBrowsableState.Never)]
public static class LengthExtensions
{
    public static mm Sum(this IEnumerable<mm> @this) => new mm(@this.Sum(x => x.Value));
    public static mm Average(this IEnumerable<mm> @this) => new mm(@this.Average(x => x.Value));

    public static cm Sum(this IEnumerable<cm> @this) => new cm(@this.Sum(x => x.Value));
    public static cm Average(this IEnumerable<cm> @this) => new cm(@this.Average(x => x.Value));

    public static dm Sum(this IEnumerable<dm> @this) => new dm(@this.Sum(x => x.Value));
    public static dm Average(this IEnumerable<dm> @this) => new dm(@this.Average(x => x.Value));

    public static m Sum(this IEnumerable<m> @this) => new m(@this.Sum(x => x.Value));
    public static m Average(this IEnumerable<m> @this) => new m(@this.Average(x => x.Value));

    public static km Sum(this IEnumerable<km> @this) => new km(@this.Sum(x => x.Value));
    public static km Average(this IEnumerable<km> @this) => new km(@this.Average(x => x.Value));

}

