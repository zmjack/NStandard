// <auto-generated/>
using System.Collections.Generic;
using System.Linq;
using static NStandard.Measures.Weight;

namespace NStandard.Measures;

public static class Weight
{
	public struct g(double value) : IMeasurable<double>
	{
		public double Value { get; set; } = value;

		public static g operator +(g left, g right) => new(left.Value + right.Value);
		public static g operator -(g left, g right) => new(left.Value - right.Value);
		public static g operator *(g left, double right) => new(left.Value * right);
		public static g operator /(g left, double right) => new(left.Value / right);
		public static g operator /(g left, g right) => left.Value / right.Value;
        
		public static bool operator ==(g left, g right) => left.Value == right.Value;
		public static bool operator !=(g left, g right) => left.Value != right.Value;
		public static bool operator <(g left, g right) => left.Value < right.Value;
		public static bool operator <=(g left, g right) => left.Value <= right.Value;
		public static bool operator >(g left, g right) => left.Value > right.Value;
		public static bool operator >=(g left, g right) => left.Value >= right.Value;
        
		public static explicit operator g(kg other) => new(other.Value * 1000);
		public static explicit operator g(t other) => new(other.Value * 1000000);
        public static implicit operator g(double value) => new g(value);

		public override string ToString() => $"{Value} g";
	}

	public struct kg(double value) : IMeasurable<double>
	{
		public double Value { get; set; } = value;

		public static kg operator +(kg left, kg right) => new(left.Value + right.Value);
		public static kg operator -(kg left, kg right) => new(left.Value - right.Value);
		public static kg operator *(kg left, double right) => new(left.Value * right);
		public static kg operator /(kg left, double right) => new(left.Value / right);
		public static kg operator /(kg left, kg right) => left.Value / right.Value;
        
		public static bool operator ==(kg left, kg right) => left.Value == right.Value;
		public static bool operator !=(kg left, kg right) => left.Value != right.Value;
		public static bool operator <(kg left, kg right) => left.Value < right.Value;
		public static bool operator <=(kg left, kg right) => left.Value <= right.Value;
		public static bool operator >(kg left, kg right) => left.Value > right.Value;
		public static bool operator >=(kg left, kg right) => left.Value >= right.Value;
        
		public static explicit operator kg(g other) => new(other.Value / 1000);
		public static explicit operator kg(t other) => new(other.Value * 1000);
        public static implicit operator kg(double value) => new kg(value);

		public override string ToString() => $"{Value} kg";
	}

	public struct t(double value) : IMeasurable<double>
	{
		public double Value { get; set; } = value;

		public static t operator +(t left, t right) => new(left.Value + right.Value);
		public static t operator -(t left, t right) => new(left.Value - right.Value);
		public static t operator *(t left, double right) => new(left.Value * right);
		public static t operator /(t left, double right) => new(left.Value / right);
		public static t operator /(t left, t right) => left.Value / right.Value;
        
		public static bool operator ==(t left, t right) => left.Value == right.Value;
		public static bool operator !=(t left, t right) => left.Value != right.Value;
		public static bool operator <(t left, t right) => left.Value < right.Value;
		public static bool operator <=(t left, t right) => left.Value <= right.Value;
		public static bool operator >(t left, t right) => left.Value > right.Value;
		public static bool operator >=(t left, t right) => left.Value >= right.Value;
        
		public static explicit operator t(g other) => new(other.Value / 1000000);
		public static explicit operator t(kg other) => new(other.Value / 1000);
        public static implicit operator t(double value) => new t(value);

		public override string ToString() => $"{Value} t";
	}

}

public static class WeightExtensions
{
    public static g Sum(this IEnumerable<g> @this) => new g(@this.Sum(x => x.Value));
    public static g Average(this IEnumerable<g> @this) => new g(@this.Average(x => x.Value));

    public static kg Sum(this IEnumerable<kg> @this) => new kg(@this.Sum(x => x.Value));
    public static kg Average(this IEnumerable<kg> @this) => new kg(@this.Average(x => x.Value));

    public static t Sum(this IEnumerable<t> @this) => new t(@this.Sum(x => x.Value));
    public static t Average(this IEnumerable<t> @this) => new t(@this.Average(x => x.Value));

}

