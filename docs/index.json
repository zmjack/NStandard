{
  "cn/Any/Any.Chain.html": {
    "href": "cn/Any/Any.Chain.html",
    "title": "| NStandard",
    "summary": "Any.Chain 转换 嵌套循环 为 单层循环。 嵌套循环 已知嵌套次数 示例 1：3 次嵌套 foreach (var i in new[] { \"A\", \"B\" }) { foreach (var j in new[] { \"a\", \"b\" }) { foreach (var k in new[] { \"1\", \"2\" }) { Console.WriteLine($\"{i}, {j}, {k}\"); } } } A, a, 1 A, a, 2 A, b, 1 A, b, 2 B, a, 1 B, a, 2 B, b, 1 B, b, 2 未知嵌套次数 示例 2：n 层嵌套（通过数组传递） var chain = Any.Chain(new[] { new[] { \"A\", \"B\" }, new[] { \"a\", \"b\" }, new[] { \"1\", \"2\" }, }) .Where(x => x.Origin == ChainOrigin.Current); foreach (var iterator in chain) { var (i, j, k) = iterator.Iterators; Console.WriteLine($\"{i}, {j}, {k}\"); } 与 嵌套循环 不同的是，ChainIterator 中的 Iterators 包含了所有的遍历值（数组）。 这意味着我们可以使用同样的方式来处理不定层数嵌套循环。 实际情况可能会更复杂，但是这种模式具有相同的特性： 数据处理通常在最里层，因为最里层拥有全部的迭代值。 其他层级可能会做一些特殊的处理，因此需要明确知道每个层级 何时开始，何时结束。 示例 3：更复杂的 3 层嵌套 foreach (var i in new[] { \"A\", \"B\" }) { // Origin = Begin, Cursor = 0 Console.WriteLine($\"Begin: {i}, ,\"); foreach (var j in new[] { \"a\", \"b\" }) { // Origin = Begin, Cursor = 1 Console.WriteLine($\"Begin: {i}, {j},\"); foreach (var k in new[] { \"1\", \"2\" }) { // Origin = Current, Cursor = 2 Console.WriteLine($\"{i}, {j}, {k}\"); } // Origin = End, Cursor = 1 Console.WriteLine($\"End: {i}, {j},\"); } // Origin = End, Cursor = 0 Console.WriteLine($\"End: {i}, ,\"); } 示例 4：更复杂的 3 次嵌套（Any.Chain） var chain = Any.Chain(new[] { new[] { \"A\", \"B\" }, new[] { \"a\", \"b\" }, new[] { \"1\", \"2\" }, }); foreach (var iterator in chain) { var (i, j, k) = iterator.Iterators; if (iterator.Origin == ChainOrigin.Begin) { Console.WriteLine($\"Begin: {i}, {j},\"); } else if (iterator.Origin == ChainOrigin.Current) { Console.WriteLine($\"{i}, {j}, {k}\"); } else if (iterator.Origin == ChainOrigin.End) { Console.WriteLine($\"End: {i}, {j},\"); } } Begin: A, , Begin: A, a, A, a, 1 A, a, 2 End: A, a, Begin: A, b, A, b, 1 A, b, 2 End: A, b, End: A, , Begin: B, , Begin: B, a, B, a, 1 B, a, 2 End: B, a, Begin: B, b, B, b, 1 B, b, 2 End: B, b, End: B, , 动态生成嵌套 从种子值为每个层级依次生成迭代器。 示例 5：九九乘法表 var chain = Any.Chain(9, new Func<int, IEnumerable<int>>[] { s => new int[s].Let(i => i + 1), i => new int[i].Let(j => j + 1), }); foreach (var iterator in chain) { var (i, j) = iterator.Iterators; if (iterator.Origin == ChainOrigin.Current) { Console.Write($\"{i}x{j} \"); } else if (iterator.Origin == ChainOrigin.End) { Console.WriteLine(); } } 1x1 2x1 2x2 3x1 3x2 3x3 4x1 4x2 4x3 4x4 5x1 5x2 5x3 5x4 5x5 6x1 6x2 6x3 6x4 6x5 6x6 7x1 7x2 7x3 7x4 7x5 7x6 7x7 8x1 8x2 8x3 8x4 8x5 8x6 8x7 8x8 9x1 9x2 9x3 9x4 9x5 9x6 9x7 9x8 9x9"
  },
  "cn/Any/Any.Flat.html": {
    "href": "cn/Any/Any.Flat.html",
    "title": "| NStandard",
    "summary": "Any.Flat 创建一个包含指定多维数组的所有元素的一维枚举。 扁平化数组 示例 1 （扁平化 多维数组） var d2 = new string[2, 2] { { \"0\", \"1\" }, { \"2\", \"3\" } }; Console.WriteLine( Any.Flat<string>(d2).Join(\", \") ); 0, 1, 2, 3 示例 2（扁平化 交叉数组） var d1_d1 = new string[2][] { new string[] { \"0\", \"1\" }, new string[] { \"2\", \"3\" }, }; Console.WriteLine( Any.Flat<string>(d1_d1).Join(\", \") ); 0, 1, 2, 3 示例 3（扁平化 交叉多维数组） var d1_d2 = new string[2][,] { new string[2, 2] { { \"0\", \"1\" }, { \"2\", \"3\" } }, new string[2, 2] { { \"4\", \"5\" }, { \"6\", \"7\" } }, }; Console.WriteLine( Any.Flat<string>(d1_d2).Join(\", \") ); 0, 1, 2, 3, 4, 5, 6, 7 示例 4（扁平化 嵌套数组） var array = new object[2] { new string[2] { \"0\", \"1\" }, new object[2] { \"2\", new string[2] { \"3\", \"4\" } } }; Console.WriteLine( Any.Flat<string>(array).Join(\", \") ); 0, 1, 2, 3, 4 扁平化非托管数组（使用指针） 示例 5（扁平化 非托管 多维数组） var d2 = new int[2, 2] { { 0, 1 }, { 2, 3 } }; var length = d2.GetSequenceLength(); fixed (int* pd2 = d2) { Console.WriteLine( Any.Flat(pd2, length).Join(\", \") ); } 0, 1, 2, 3 示例 6（扁平化 非托管 交叉数组） var d1_d1 = new int[2][] { new int[] { 0, 1 }, new int[] { 2, 3 }, }; var lengths = d1_d1.Select(x => x.GetSequenceLength()).ToArray(); fixed (int* pd0 = d1_d1[0]) fixed (int* pd1 = d1_d1[1]) { Console.WriteLine( Any.Flat(new[] { pd0, pd1 }, lengths).Join(\", \") ); } 0, 1, 2, 3 案例 合计每个数组的所有元素 var numbers = new[] { new[] { 1, 2, 3 }, new[] { 4, 5, 6 }, new[] { 7, 8, 9 }, }; Console.WriteLine( Any.Flat<int>(numbers).Sum(x => x) ); 45"
  },
  "cn/Any/Any.Forward.html": {
    "href": "cn/Any/Any.Forward.html",
    "title": "| NStandard",
    "summary": "Any.Forward 按指定路径依次获取元素。 深层遍历 示例 1 （最里面的 Exception） var exception = new Exception(\"3\", new Exception(\"2\", new Exception(\"1\"))); var forwards = Any.Forward(exception, x => x.InnerException); /* * Exception 3 = First * - Exception 2 * - - Exception 1 = Last */ Assert.Equal(\"1\", (from ex in forwards select ex).Last().Message);"
  },
  "cn/Any/Any.ReDim.html": {
    "href": "cn/Any/Any.ReDim.html",
    "title": "| NStandard",
    "summary": "Any.ReDim 为数组重新分配空间。 示例 1（减少维度空间） var d2 = new int[3, 3] { { 0, 1, 2 }, { 3, 4, 5 }, { 6, 7, 8 } }; Any.ReDim(ref d2, 2, 2); for (int i = 0; i < d2.GetLength(0); i++) { var row = new int[d2.GetLength(1)].Let(j => d2[i, j]); Console.WriteLine(row.Join(\", \")); } 0, 1 3, 4 示例 2（扩大维度空间） var d2 = new int[3, 3] { { 0, 1, 2 }, { 3, 4, 5 }, { 6, 7, 8 } }; Any.ReDim(ref d2, 4, 4); for (int i = 0; i < d2.GetLength(0); i++) { var row = new int[d2.GetLength(1)].Let(j => d2[i, j]); Console.WriteLine(row.Join(\", \")); } 0, 1, 2, 0 3, 4, 5, 0 6, 7, 8, 0 0, 0, 0, 0"
  },
  "cn/Any/Any.Zip.html": {
    "href": "cn/Any/Any.Zip.html",
    "title": "| NStandard",
    "summary": "Any.Zip 并行迭代几个可迭代对象，为每个对象项目生成元组。 例如： var numbers = new[] { 1, 2, 3 }; var weeks = new[] { \"Monday\", \"Tuesday\", \"Wednesday\" }; var abbrWeeks = new[] { \"Mon.\", \"Tues.\", \"Wed.\" }; foreach(var item in Any.Zip(numbers, weeks, abbrweeks)) { Console.WriteLine(item); } (1, Monday, Mon.) (2, Tuesday, Tues.) (3, Wednesday, Wed.) 由于每个返回项都是 ValueTuple，所以它能够自动解构。 foreach (var (number, week, abbrWeek) in Any.Zip(numbers, weeks, abbrWeeks)) { Console.WriteLine($\"({number}, {week}, {abbrWeek})\"); } (1, Monday, Mon.) (2, Tuesday, Tues.) (3, Wednesday, Wed.) Any.Zip 方法最多支持 8 个参数，如果需要更多参数，可以使用嵌套。 foreach (var (number, (week, abbrWeek)) in Any.Zip(numbers, Any.Zip(weeks, abbrWeeks))) { Console.WriteLine($\"({number}, {week}, {abbrWeek})\"); } 案例 合计每列的元素 var numbers = new[] { new[] { 1, 2, 3 }, new[] { 4, 5, 6 }, new[] { 7, 8, 9 }, }; var zip = Any.Zip(numbers, col => col.Sum()); Console.WriteLine( $\"[{string.Join(\", \", zip)}]\" ); [12, 15, 18] 矩阵转置 void Main() { var numbers = new[] { new[] { 1, 2, 3 }, new[] { 4, 5, 6 }, new[] { 7, 8, 9 }, }; PrintMatrix(numbers); PrintMatrix(Any.Zip(numbers)); } void PrintMatrix(IEnumerable<IEnumerable<int>> matrix) { Console.WriteLine( string.Join(Environment.NewLine, ( matrix.Select(row => $\"[{string.Join(\", \", row)}]\") )) ); Console.WriteLine(); } [1, 2, 3] [4, 5, 6] [7, 8, 9] [1, 4, 7] [2, 5, 8] [3, 6, 9]"
  },
  "cn/ArrayExtensions.html": {
    "href": "cn/ArrayExtensions.html",
    "title": "| NStandard",
    "summary": "ArrayExtensions 原型映射 Map 映射原数组为新类型数组，且不改变整体结构。 示例 1（ 1d - 1d ） var d1_d1 = new string[2][] { new string[1] { \"0\" }, new string[2] { \"1\", \"2\" }, }; var result = d1_d1.Map((string s) => int.Parse(s)) as int[][]; Assert.Equal(new[] { 0, 1, 2 }, Any.Flat<int>(result)); 示例 2（ 1d - 2d ） var d1_d2 = new string[2][,] { new string[2, 1] { { \"0\" }, { \"1\" }, }, new string[1, 2] { { \"2\", \"3\" }, }, }; var result = d1_d2.Map((string s) => int.Parse(s)) as int[][,]; Assert.Equal(new[] { 0, 1, 2, 3 }, Any.Flat<int>(result)); 示例 3（ 1d - 2d - 1d ） var d1_d2_d1 = new string[2][,][] { new string[1, 2][] { { new string [1] { \"0\", }, new string [2] { \"1\", \"2\" }, }, }, new string[2, 1][] { { new string [2] { \"3\", \"4\",}, }, { new string [3] { \"5\", \"6\", \"7\"}, }, }, }; var result = d1_d2_d1.Map((string s) => int.Parse(s)) as int[][,][]; Assert.Equal(new[] { 0, 1, 2, 3, 4, 5, 6, 7 }, Any.Flat<int>(result));"
  },
  "cn/Compatibility.html": {
    "href": "cn/Compatibility.html",
    "title": "| NStandard",
    "summary": "Compatibility NStandard 移植了 .NET Core 的部分功能，以便在 .NET Framework 中使用。 命名空间 Class / Strcut 兼容性 System HashCode = .NET Framework < .NET Standard 2.1 < .NET Core App 2.1 System ITuple < .NET Framework 4.7 < .NET Standard 2.1 < .NET Core App 2.0 System Tuple < .NET Framework 4.5.1 System FormattableString < .NET Framework 4.6 < .NET Standard 1.3 System.Collections IStructuralComparable IStructuralEquatable < .NET Framework 4.5.1 System.Reflection CustomAttributeExtensions < .NET Framework 4.5.1"
  },
  "cn/DateTimeExtensions.html": {
    "href": "cn/DateTimeExtensions.html",
    "title": "| NStandard",
    "summary": "DateTime Extensions StartOf & EndOf 提供 DateTime / DateTimeOffset 将时间返回到起点或终点的操作。 StartOf 函数组: Name Example Result StartOfYear (2020, 11, 13, 20, 30, 1) .StartOfYear() 2020/ 1/1 0:00:00:000 StartOfMonth (2020, 11, 13, 20, 30, 1) .StartOfMonth() 2020/11/ 1 0:00:00:000 StartOfDay (2020, 11, 13, 20, 30, 1) .StartOfDay() 2020/11/13 0:00:00:000 StartOfHour (2020, 11, 13, 20, 30, 1) .StartOfHour() 2020/11/13 20: 00:00:000 StartOfMinute (2020, 11, 13, 20, 30, 1) .StartOfMinute() 2020/11/13 20:30: 00:000 StartOfSecond (2020, 11, 13, 20, 30, 1) .StartOfSecond() 2020/11/13 20:30:01: 000 EndOf 函数组: Name Example Result EndOfYear (2020, 11, 13, 20, 30, 1) .EndOfYear() 2020/ 12/31 23:59:59:999 EndOfMonth (2020, 11, 13, 20, 30, 1) .EndOfMonth() 2020/11/ 30 23:59:59:999 EndOfDay (2020, 11, 13, 20, 30, 1) .EndOfDay() 2020/11/13 23:59:59:999 EndOfHour (2020, 11, 13, 20, 30, 1) .EndOfHour() 2020/11/13 20: 59:59:999 EndOfMinute (2020, 11, 13, 20, 30, 1) .EndOfMinute() 2020/11/13 20:30: 59:999 EndOfSecond (2020, 11, 13, 20, 30, 1) .EndOfSecond() 2020/11/13 20:30:01: 999 Week 获取 一年中 指定日期的周数。 /* 2020 - 01 * Su Mo Tu We Th Fr Sa *[ ( 1) 2 3 4 ] *[( 5) 6 7 8 9 10 11 ] * 12 13 14 15 16 17 18 * 19 20 21 22 23 24 25 * 26 27 28 29 30 31 */ Example Result (2020, 1, 1) .Week() 0 (2020, 1, 5) .Week() 1 WeekInMonth 获取指定日期 一个月 中的周数。 /* 2012 - 04 2012 - 04 * Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa * [ 1 [ 1] * 2 3 4 5 6] [ 7 8 [ 2 3 4 5 6 7 8] * 9 10 11 12 13] [14 15 [ 9 10 11 12 13 14 15] * (16) 17 18 19 20] [21 22 [(16) 17 18 19 20 21 22] * 23 24 25 26 27 28 29 23 24 25 26 27 28 29 * 30 30 */ Example Result (2012, 4, 16) .WeekInMonth ( DayOfWeek.Friday ) 2 (2012, 4, 16) .WeekInMonth ( DayOfWeek.Sunday ) 3 AddDays 提供计算 工作日 或 非工作日 的特殊算术方法。 public static DateTime AddDays(this DateTime @this, int value, DayMode mode) DayMode 声明为： public enum DayMode { Undefined, Weekday, Weekend, } /* 2020 - 12 2020 - 12 * Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa * 1 2 3 4 5 * 6 7 8 9 10 11 12 * (13) 14 15 16 17 18 [19] * 20 [21] 22 23 24 25 26 * 27 28 29 30 31 */ Example Result (2020, 12, 13) .AddDays ( 6, DayMode.Weekday ) (2020, 12, 21) (2020, 12, 13) .AddDays ( 1, DayMode.Weekend ) (2020, 12, 19) AddTotalYears & AddTotalMonths AddTotalYears ：返回一个新的 DateTime，它将指定的 年数差值 相加到此实例值中。 AddTotalMonths : 返回一个新的 DateTime ，它将指定的 月数差值 相加到此实例值中。 Example Result (2000, 2, 29) .AddTotalYears ( 1 ) (2001, 3, 1) (2001, 3, 1) .AddTotalYears ( -1 ) (2000, 3, 1) Elapsed... 从 DateTime.MinValue 获取经过 ... 的单位次数。 Example Result (2012, 4, 16) .ElapsedDays ( ) 734608 (2012, 4, 16) .ElapsedMonths ( ) 24135.5"
  },
  "cn/DpContainer.html": {
    "href": "cn/DpContainer.html",
    "title": "| NStandard",
    "summary": "DpContainer DpContainer 用于动态规划计算。 以斐波那契函数为例。 递归代码 int Fib(int n) { if (n == 0 || n == 1) return 1; else return Fib(n - 1) + Fib(n - 2); } void Main() { Fib(42).Dump(); } DP 代码 1（使用 class） class DpFib : DpContainer<int, int> { public override int StateTransfer(int n) { if (n == 0 || n == 1) return 1; else return this[n - 1] + this[n - 2]; } } void Main() { var fib = new DpFib(); fib[42].Dump(); } DP 代码 2（使用函数） int Fib(DefaultDpContainer<int, int> dp, int n) { if (n == 0 || n == 1) return 1; else return dp[n - 1] + dp[n - 2]; } void Main() { var fib = DpContainer.Create<int, int>(Fib); fib[42].Dump(); // same as Fib(fib, 42).Dump(); } 正确结果是 433494437. 上述代码得到正确结果所需的时间大致如下： Name Elapsed 递归代码 约 3.823 秒。 * DP 代码 1（使用 class） 约 0.010 秒。 DP 代码 2（使用函数） 约 0.011 秒。"
  },
  "cn/Evaluator.html": {
    "href": "cn/Evaluator.html",
    "title": "| NStandard",
    "summary": "Numerical Evaluator NumericalEvaluator 用于解析支持字符串表达式。 例如： Evaluator.Numerical.Eval(\"2 >= 3 ? 5 : 7\"); 结果为 7. 我们提供了一组丰富的运算符： 优先级 运算符 描述 示例 1 ** 求幂。 (2 ** 3) 等于 8. 3 // 整除，向下取整。 (7 // 5) 等于 1. * 乘法。 (2 * 3) 等于 6. / 除法。 (7 / 5) 等于 1.4. % 取模。 (7 % 5) 等于 2. 4 + 加法。 (2 + 3) 等于 5. - 减法。 (7 - 5) 等于 2. 6 > 大于。 (7 > 5) 等于 1. >= 大于等于。 (7 >= 5) 等于 1. < 小于。 (2 < 3) 等于 1. <= 小于等于。 (2 <= 3) 等于 1. 7 == 等于。 (7 == 7) 等于 1. != 不等于。 (2 != 3) 等于 1. 11 and 如果 左表达式 为 0，返回 左表达式，否则 返回 右表达式。 (3 and 5) 等于 5. (0 and 3) 等于 0. 12 or 如果 左表达式 不为 0，返回 左表达式，否则 返回 右表达式。 (3 or 5) 等于 3. (0 or 3) 等于 3. 13 ?? 如果 左表达式 为 double.NaN，返回 右表达式，否则 返回 左表达式。 (5 ?? 7) 等于 5. (NaN ?? 7) 等于 7. 14 ? 如果 左表达式 不为 0，返回 右表达式，否则 返回 double.NaN。 (2 > 3 ? 5) 等于 NaN. (2 < 3 ? 5) 等于 5. 15 : 如果 左表达式 为 double.NaN，返回 右表达式，否则 返回 左表达式。 (2 > 3 ? 5 : 7) 等于 7. (2 < 3 ? 5 : 7) 等于 5. 内置的 一元运算符: 运算符 描述 示例 not 等同运算 !x. not 0 = 1 + 等同运算 +x. + ( 2 + 3 ) = 5 - 等同运算 –x. - ( 2 + 3 ) = -5 内置的 运算函数: 运算符 描述 示例 ( ... ) 高优先级运算。 2 * ( 3 + 5 ) = 16 abs( ... ) 返回双精度浮点数的绝对值。 abs(-2) = 2 sqrt( ... ) 返回指定数值的平方根。 sqrt(9) = 3 ceil( ... ) 返回大于或等于指定双精度浮点数的最小整数值。 ceil(6.8) = 7 floor( ... ) 返回小于或等于指定双精度浮点数的最大整数。 floor(6.8) = 6 sin( ... ) 返回指定角度的正弦值。 sin({Math.PI / 2}) = 1 cos( ... ) 返回指定角度的余弦值。 cos(0) = 1 tan( ... ) 返回指定角度的正切值。 tan({Math.PI / 4}) = 1 asin( ... ) 返回正弦为指定数值的角度。 sin(1) = {Math.PI / 2} acos( ... ) 返回余弦为指定数值的角度。 acos(1) = 0 atan( ... ) 返回正切为指定数值的角度。 atan(1) = {Math.PI / 4} sinh( ... ) 返回指定角度的双曲正弦值。 sinh(0.1) = 0.1001... cosh( ... ) 返回指定角度的双曲余弦值。 cosh(0.1) = 1.0050... tanh( ... ) 返回指定角度的双曲正切值。 tanh(0.1) = 0.0996... 不带参数的求值示例： Evaluator.Numerical.Eval(\"2 >= 3 ? 5 : 7\"); 带参数的求值求例： var exp = \"${price} >= 100 ? ${price} * 0.8 : ${price}\"; var func = Evaluator.Numerical.Compile(exp); var result = func(new { Price = 100 }); // 结果为 80. var exp = \"${price} >= 100 ? ${price} * 0.8 : ${price}\"; var func = Evaluator.Numerical.Compile(exp); var result = func(new Dictionary<string, double> { [\"price\"] = 100 }); // 结果为 80. class Item { public double Price { get; set; } } void Main() { var exp = \"${price} >= 100 ? ${price} * 0.8 : ${price}\"; var func = Evaluator.Numerical.Compile<Item>(exp); var result = func(new Item { Price = 100 }); // 结果为 80. } 值得注意的是，这些运算符（ ? 和 : ）是特定的。 结合使用，它将具有与三元运算符 ( ? : ) 相同的效果。 编译阶段 比如把字符串解析成函数。 var exp = \"${x} + sqrt(abs(${x} * 3)) * 3\"; 将字符串解析为节点集合。 问题 节点类型 索引 值 Parameter 0 ${x} 节点歧义 UnaryOperator, BinaryOperator 5 + StartBracket 7 sqrt( StartBracket 12 abs( Parameter 16 ${x} BinaryOperator 21 * Operand 23 3 EndBracket 24 ) EndBracket 25 ) BinaryOperator 27 * Operand 29 3 消除节点歧义。 节点类型 索引 值 Parameter 0 ${x} BinaryOperator 5 + StartBracket 7 sqrt( StartBracket 12 abs( Parameter 16 ${x} BinaryOperator 21 * Operand 23 3 EndBracket 24 ) EndBracket 25 ) BinaryOperator 27 * Operand 29 3 构建 表达式。 ( IIF(p.ContainsKey(\"x\"), p.get_Item(\"x\"), 0) + ( value(NStandard.Evaluators.NumericalEvaluator).Bracket ( \"sqrt(\", \")\", value(NStandard.Evaluators.NumericalEvaluator).Bracket ( \"abs(\", \")\", ( IIF(p.ContainsKey(\"x\"), p.get_Item(\"x\"), 0) * 3 ) ) ) * 3 ) ) 将表达式编译为 Func<object, double>。 var func = Evaluator.Numerical.Compile(exp); 调用 Func<object, double>。 使用 匿名对象： var result = func(new { x = -3 }); 或者 Dictionary<string, double>: var result = func(new Dictionary<string, double> { [\"x\"] = -3 }); 自定义求值器 扩展 NumericalEvaluator 创建一个更多运算符的求值器： public class MyEvaluator : NumericalEvaluator { public MyEvaluator() { Define(\"!\", value => value != 0d ? 0d : 1d); DefineBracket(new(\"|\", \"|\"), value => Math.Abs(value)); Initialize(); } } 使用 | ... | 计算数值的绝对值。 使用 ! 对 布尔值 取反。 Note 在构造函数中调用 Initialize 方法可以为第一次操作提供更好的性能。 让我们对下面的字符串求值： \"|-9| + !0\" var evaluator = new MyEvaluator(); var result = evaluator.Eval(\"|-9| + !0\"); // |-9| is abs(-9) = 9 // !0 is 1 // 结果为 10."
  },
  "cn/SequenceInputStream.html": {
    "href": "cn/SequenceInputStream.html",
    "title": "| NStandard",
    "summary": "SequenceInputStream SequenceInputStream 可以将多个流组合成一个流。 示例 using var stream = new SequenceInputStream( new MemoryStream(\"123\".Bytes(Encoding.UTF8)), new MemoryStream(\"456\".Bytes(Encoding.UTF8)), new MemoryStream(\"789\".Bytes(Encoding.UTF8)) ); using var reader = new StreamReader(stream); var result = reader.ReadToEnd(); // 123456789"
  },
  "cn/State.html": {
    "href": "cn/State.html",
    "title": "| NStandard",
    "summary": "State State 用来进行数据绑定。 例如，这里有两个类型为 State<int> 变量 a b。 using var a = State.Use(2); using var b = State.Use(3); 以及一个通过 a + b 自动计算得到的变量 c。 using var c = State.From(() => a + b); // c.Value 的值为 5。 Console.WriteLine(c.Value); 当 a b 任意 Value 改变时，c 值会根据公式同时被改变。 a.Value = 7; // c.Value 的值为 10。 Console.WriteLine(c.Value); 实现过程 State 会在创建时收集依赖，并为每个依赖项绑定通知函数。 随后，若依赖项的值发生变化，会通知到目标 State 对象为当前值设置过期。 State 对象在获取值时，如果当前值已过期，则会重新计算最新值并缓存。 一般来说，State 应该与 using 一起使用，以避免可能的内存泄漏。 但这不并不是必须的，你仍然可以通过手动管理来提升性能，特别是对大量 State 对象管理。 下面通过例子来说明 State 是如何工作的。 定义变量 a b： using var a = State.Use(2); using var b = State.Use(3); 定义变量 c，取值为 a + b。 （该操作会同时会为 a b 订阅通知事件。） var c = State.From(() => a + b); 获取 c 值并输出。 （该操作将计算公式并缓存结果。） Console.WriteLine(c.Value); 改变 a 值为 7。 （该操作会将 c 值设置为 已过期。） a.Value = 7; 重新获取 c 值并输出。 （该操作将重新计算公式并缓存结果。） Console.WriteLine(c.Value); 处置 c。 （该操作将退订其依赖项的通知事件。） c.Dispose(); 避免内存泄漏 参考下面的例子： root 为 static State 对象。 成员函数中的 State 对象数组，依赖于 root。 因为这些 State 对象订阅了 static State 的更新通知，所以在函数生命周期结束时，它们不会被回收。 为了避免内存泄漏，应该使用 using 或手动调用 Dispose。 调用被订阅者的 Release 方法，取消依赖于该对象的所有订阅，也能够避免内存泄漏，并且执行效率更高。 class Program { static State<int> root = State.Use(1); static void Main(string[] args) { PrintMemory(\"Beginning:\"); MakeSomeStateObjects(1_000); PrintMemory(\"Before release:\"); root.Release(); PrintMemory(\"After release:\"); } static void MakeSomeStateObjects(int count) { var States = new State<int>[count]; for (int i = 0; i < count; i++) { var index = i; States[i] = State.From(() => root + index); } //States.DisposeAll(); } static void PrintMemory(string title) { Console.WriteLine($\"{title，-38}{GC.GetTotalMemory(true) / 1024:N0} KB\"); } } Beginning: 504 KB Before release: 2,018 KB After release: 533 KB 可选事件 事件名 签名 描述 Changed void Changed (TValue value) 如果值被 显式更改 时触发。 Updating void Updating (TValue value) 如果值被 设置过期 时触发。"
  },
  "cn/UnitValue.html": {
    "href": "cn/UnitValue.html",
    "title": "| NStandard",
    "summary": "UnitValue UnitValue 用于对执行带单位的数值运算。 例如，StorageValue 是实现了 IUnitValue 的结构体： var a = StorageValue.Parse(\".5 MB\"); var b = new StorageValue(512, \"KB\"); var c = a + b; var mb = c.GetValue(\"MB\"); // 1 var kb = c.GetValue(\"KB\"); // 1024 支持数学运算： 加法 (+) a + b 减法 (-) a - b 乘法 (*) a * 2 除法 (/) a / 2 比较 ( ==, !=, <, <=, >, >= ) a == b a != b a < b a <= b a > b a >= b 多值相加 构建复杂结构体是一项相对耗时的操作。 因此，将每个数值依次相加是低效的。 我们提供了更高效的方法（使用 QuickSum 函数）来处理这种情况。 例如，现在有若干 StorageValues: var values = new StorageValue[100_000_000].Let(i => new StorageValue(i)); 然后，计算他们的和值： ✔️ 考虑使用（约 1.00 秒） var sum = new StorageValue(); sum.QuickSum(values); ❌ 避免使用（约 4.00 秒） var sum = new StorageValue(); foreach (var value in values) { sum += value; } 使用 LinqSharp ✔️ 考虑使用（约 1.00 秒） var sum = values.QSum(); ❌ 避免使用（约 4.00 秒） var sum = values.Sum();"
  },
  "cn/field-feature.html": {
    "href": "cn/field-feature.html",
    "title": "Field Feature | NStandard",
    "summary": "Field Feature Auto properties only allow for directly setting or getting the backing field, giving some control only by placing access modifiers on the accessors. Sometimes there is a need to have additional control over what happens in one or both accessors, but this confronts users with the overhead of declaring a backing field. The backing field name must then be kept in sync with the property, and the backing field is scoped to the entire class which can result in accidental bypassing of the accessors from within the class. This is the one of implementation: public partial class LegacyModel { private int _number; public int Number { get => _number; set => _number = value; } private int[] _numbers; public int[] Numbers { get => _numbers; set => _numbers = value; } } However, we hope to avoid manually declaring backing fields for older projects. Use FieldFeature to enable the generator to analyze the code of a class or struct, and use FieldBackend to hide the backing fields: [FieldFeature] public partial class Model { [FieldBackend] public int Number { get => GetValue(); set => SetValue(value); } [FieldBackend] public int[] Numbers { get => GetValue(); set => SetValue(value); } } .NET 10 (C# 14) added the field keyword to handle this situation. public class Model { public int Number { get => field; set => field = value; } public int[] Numbers { get => field; set => field = value; } }"
  },
  "cn/getting-started.html": {
    "href": "cn/getting-started.html",
    "title": "Getting Started | NStandard",
    "summary": "Getting Started"
  },
  "cn/introduction.html": {
    "href": "cn/introduction.html",
    "title": "Introduction | NStandard",
    "summary": "Introduction"
  },
  "en/Any/Any.Chain.html": {
    "href": "en/Any/Any.Chain.html",
    "title": "| NStandard",
    "summary": "Any.Chain Transform nested loops to a single loop Nested loop Known nesting times Example 1: 3 nested loops foreach (var i in new[] { \"A\", \"B\" }) { foreach (var j in new[] { \"a\", \"b\" }) { foreach (var k in new[] { \"1\", \"2\" }) { Console.WriteLine($\"{i}, {j}, {k}\"); } } } A, a, 1 A, a, 2 A, b, 1 A, b, 2 B, a, 1 B, a, 2 B, b, 1 B, b, 2 Unknown nesting times Example 2: 3 nested loops (Passing through array) var chain = Any.Chain(new[] { new[] { \"A\", \"B\" }, new[] { \"a\", \"b\" }, new[] { \"1\", \"2\" }, }) .Where(x => x.Origin == ChainOrigin.Current); foreach (var iterator in chain) { var (i, j, k) = iterator.Iterators; Console.WriteLine($\"{i}, {j}, {k}\"); } Different from Nested Loop, Iterators in ChainIterator contains all traversal values (arrays). This means we can handle nested loops in the same way. The actual situation may be more complicated, but they have the same characteristics: Data processing is usually in the innermost layer, because the innermost layer has all the iteration values. Other layers may do some special processing, so you need to know exactly when each layer starts and ends. Example 3: More complex 3 nested loops foreach (var i in new[] { \"A\", \"B\" }) { // Origin = Begin, Cursor = 0 Console.WriteLine($\"Begin: {i}, ,\"); foreach (var j in new[] { \"a\", \"b\" }) { // Origin = Begin, Cursor = 1 Console.WriteLine($\"Begin: {i}, {j},\"); foreach (var k in new[] { \"1\", \"2\" }) { // Origin = Current, Cursor = 2 Console.WriteLine($\"{i}, {j}, {k}\"); } // Origin = End, Cursor = 1 Console.WriteLine($\"End: {i}, {j},\"); } // Origin = End, Cursor = 0 Console.WriteLine($\"End: {i}, ,\"); } Example 4: More complex 3 nested loops (Any.Chain) var chain = Any.Chain(new[] { new[] { \"A\", \"B\" }, new[] { \"a\", \"b\" }, new[] { \"1\", \"2\" }, }); foreach (var iterator in chain) { var (i, j, k) = iterator.Iterators; if (iterator.Origin == ChainOrigin.Begin) { Console.WriteLine($\"Begin: {i}, {j},\"); } else if (iterator.Origin == ChainOrigin.Current) { Console.WriteLine($\"{i}, {j}, {k}\"); } else if (iterator.Origin == ChainOrigin.End) { Console.WriteLine($\"End: {i}, {j},\"); } } Begin: A, , Begin: A, a, A, a, 1 A, a, 2 End: A, a, Begin: A, b, A, b, 1 A, b, 2 End: A, b, End: A, , Begin: B, , Begin: B, a, B, a, 1 B, a, 2 End: B, a, Begin: B, b, B, b, 1 B, b, 2 End: B, b, End: B, , Dynamically generate nested Generate iterators for each level in turn from the seed value. Example 5: multiplication table var chain = Any.Chain(9, new Func<int, IEnumerable<int>>[] { s => new int[s].Let(i => i + 1), i => new int[i].Let(j => j + 1), }); foreach (var iterator in chain) { var (i, j) = iterator.Iterators; if (iterator.Origin == ChainOrigin.Current) { Console.Write($\"{i}x{j} \"); } else if (iterator.Origin == ChainOrigin.End) { Console.WriteLine(); } } 1x1 2x1 2x2 3x1 3x2 3x3 4x1 4x2 4x3 4x4 5x1 5x2 5x3 5x4 5x5 6x1 6x2 6x3 6x4 6x5 6x6 7x1 7x2 7x3 7x4 7x5 7x6 7x7 8x1 8x2 8x3 8x4 8x5 8x6 8x7 8x8 9x1 9x2 9x3 9x4 9x5 9x6 9x7 9x8 9x9"
  },
  "en/Any/Any.Flat.html": {
    "href": "en/Any/Any.Flat.html",
    "title": "| NStandard",
    "summary": "Any.Flat Creates a one-dimensional enumeration containing all elements of the specified multidimensional arrays. Flat any array Example 1 ( Flat multidimensional array ) var d2 = new string[2, 2] { { \"0\", \"1\" }, { \"2\", \"3\" } }; Console.WriteLine( Any.Flat<string>(d2).Join(\", \") ); 0, 1, 2, 3 Example 2 ( Flat jagged array ) var d1_d1 = new string[2][] { new string[] { \"0\", \"1\" }, new string[] { \"2\", \"3\" }, }; Console.WriteLine( Any.Flat<string>(d1_d1).Join(\", \") ); 0, 1, 2, 3 Example 3（Flat jagged multidimensional array） var d1_d2 = new string[2][,] { new string[2, 2] { { \"0\", \"1\" }, { \"2\", \"3\" } }, new string[2, 2] { { \"4\", \"5\" }, { \"6\", \"7\" } }, }; Console.WriteLine( Any.Flat<string>(d1_d2).Join(\", \") ); 0, 1, 2, 3, 4, 5, 6, 7 Example 4 ( Flat nested array ) var array = new object[2] { new string[2] { \"0\", \"1\" }, new object[2] { \"2\", new string[2] { \"3\", \"4\" } } }; Console.WriteLine( Any.Flat<string>(array).Join(\", \") ); 0, 1, 2, 3, 4 Flat unmanaged array ( use pointer ) Example 5 ( Flat unmanaged multidimensional array ) var d2 = new int[2, 2] { { 0, 1 }, { 2, 3 } }; var length = d2.GetSequenceLength(); fixed (int* pd2 = d2) { Console.WriteLine( Any.Flat(pd2, length).Join(\", \") ); } 0, 1, 2, 3 Example 6 ( Flat unmanaged jagged array ) var d1_d1 = new int[2][] { new int[] { 0, 1 }, new int[] { 2, 3 }, }; var lengths = d1_d1.Select(x => x.GetSequenceLength()).ToArray(); fixed (int* pd0 = d1_d1[0]) fixed (int* pd1 = d1_d1[1]) { Console.WriteLine( Any.Flat(new[] { pd0, pd1 }, lengths).Join(\", \") ); } 0, 1, 2, 3 Cases Sum all the elements of each array var numbers = new[] { new[] { 1, 2, 3 }, new[] { 4, 5, 6 }, new[] { 7, 8, 9 }, }; Console.WriteLine( Any.Flat<int>(numbers).Sum(x => x) ); 45"
  },
  "en/Any/Any.Forward.html": {
    "href": "en/Any/Any.Forward.html",
    "title": "| NStandard",
    "summary": "Any.Forward Get elements sequentially by the specified path. Deep traversal Example 1 ( Innermost Exception ) var exception = new Exception(\"3\", new Exception(\"2\", new Exception(\"1\"))); var forwards = Any.Forward(exception, x => x.InnerException); /* * Exception 3 = First * - Exception 2 * - - Exception 1 = Last */ Assert.Equal(\"1\", (from ex in forwards select ex).Last().Message);"
  },
  "en/Any/Any.ReDim.html": {
    "href": "en/Any/Any.ReDim.html",
    "title": "| NStandard",
    "summary": "Any.ReDim Reallocates storage space for an array variable. Example 1 ( Shrink space ) var d2 = new int[3, 3] { { 0, 1, 2 }, { 3, 4, 5 }, { 6, 7, 8 } }; Any.ReDim(ref d2, 2, 2); for (int i = 0; i < d2.GetLength(0); i++) { var row = new int[d2.GetLength(1)].Let(j => d2[i, j]); Console.WriteLine(row.Join(\", \")); } 0, 1 3, 4 Example 2 ( Expand space ) var d2 = new int[3, 3] { { 0, 1, 2 }, { 3, 4, 5 }, { 6, 7, 8 } }; Any.ReDim(ref d2, 4, 4); for (int i = 0; i < d2.GetLength(0); i++) { var row = new int[d2.GetLength(1)].Let(j => d2[i, j]); Console.WriteLine(row.Join(\", \")); } 0, 1, 2, 0 3, 4, 5, 0 6, 7, 8, 0 0, 0, 0, 0"
  },
  "en/Any/Any.Zip.html": {
    "href": "en/Any/Any.Zip.html",
    "title": "| NStandard",
    "summary": "Any.Zip Iterate over several iterables in parallel, producing tuples with an item from each one. Example: var numbers = new[] { 1, 2, 3 }; var weeks = new[] { \"Monday\", \"Tuesday\", \"Wednesday\" }; var abbrWeeks = new[] { \"Mon.\", \"Tues.\", \"Wed.\" }; foreach(var item in Any.Zip(numbers, weeks, abbrweeks)) { Console.WriteLine(item); } (1, Monday, Mon.) (2, Tuesday, Tues.) (3, Wednesday, Wed.) Since each item is a ValueTuple, it can also be automatically deconstructed. foreach (var (number, week, abbrWeek) in Any.Zip(numbers, weeks, abbrWeeks)) { Console.WriteLine($\"({number}, {week}, {abbrWeek})\"); } (1, Monday, Mon.) (2, Tuesday, Tues.) (3, Wednesday, Wed.) The Any.Zip method supports up to eight parameters, and nesting can be used if more parameters are required. foreach (var (number, (week, abbrWeek)) in Any.Zip(numbers, Any.Zip(weeks, abbrWeeks))) { Console.WriteLine($\"({number}, {week}, {abbrWeek})\"); } Cases Sum the elements of each column var numbers = new[] { new[] { 1, 2, 3 }, new[] { 4, 5, 6 }, new[] { 7, 8, 9 }, }; var zip = Any.Zip(numbers, col => col.Sum()); Console.WriteLine( $\"[{string.Join(\", \", zip)}]\" ); [12, 15, 18] Matrix Transpose void Main() { var numbers = new[] { new[] { 1, 2, 3 }, new[] { 4, 5, 6 }, new[] { 7, 8, 9 }, }; PrintMatrix(numbers); PrintMatrix(Any.Zip(numbers)); } void PrintMatrix(IEnumerable<IEnumerable<int>> matrix) { Console.WriteLine( string.Join(Environment.NewLine, ( matrix.Select(row => $\"[{string.Join(\", \", row)}]\") )) ); Console.WriteLine(); } [1, 2, 3] [4, 5, 6] [7, 8, 9] [1, 4, 7] [2, 5, 8] [3, 6, 9]"
  },
  "en/ArrayExtensions.html": {
    "href": "en/ArrayExtensions.html",
    "title": "| NStandard",
    "summary": "Array Extensions Map Map the original array to a new type array without changing the overall structure. Example 1 ( 1d - 1d ) var d1_d1 = new string[2][] { new string[1] { \"0\" }, new string[2] { \"1\", \"2\" }, }; var result = d1_d1.Map((string s) => int.Parse(s)) as int[][]; Assert.Equal(new[] { 0, 1, 2 }, Any.Flat<int>(result)); Example 2 ( 1d - 2d ) var d1_d2 = new string[2][,] { new string[2, 1] { { \"0\" }, { \"1\" }, }, new string[1, 2] { { \"2\", \"3\" }, }, }; var result = d1_d2.Map((string s) => int.Parse(s)) as int[][,]; Assert.Equal(new[] { 0, 1, 2, 3 }, Any.Flat<int>(result)); Example 3 ( 1d - 2d - 1d ) var d1_d2_d1 = new string[2][,][] { new string[1, 2][] { { new string [1] { \"0\", }, new string [2] { \"1\", \"2\" }, }, }, new string[2, 1][] { { new string [2] { \"3\", \"4\",}, }, { new string [3] { \"5\", \"6\", \"7\"}, }, }, }; var result = d1_d2_d1.Map((string s) => int.Parse(s)) as int[][,][]; Assert.Equal(new[] { 0, 1, 2, 3, 4, 5, 6, 7 }, Any.Flat<int>(result));"
  },
  "en/Compatibility.html": {
    "href": "en/Compatibility.html",
    "title": "| NStandard",
    "summary": "Compatibility NStandard ports parts of .NET Core for use within the .NET Framework. Namespace Class or Strcut Compatibility System HashCode = .NET Framework < .NET Standard 2.1 < .NET Core App 2.1 System ITuple < .NET Framework 4.7 < .NET Standard 2.1 < .NET Core App 2.0 System Tuple < .NET Framework 4.5.1 System FormattableString < .NET Framework 4.6 < .NET Standard 1.3 System.Collections IStructuralComparable IStructuralEquatable < .NET Framework 4.5.1 System.Reflection CustomAttributeExtensions < .NET Framework 4.5.1"
  },
  "en/DateTimeExtensions.html": {
    "href": "en/DateTimeExtensions.html",
    "title": "| NStandard",
    "summary": "DateTime Extensions StartOf & EndOf Provides operations for the DateTime / DateTimeOffset to return time to a starting point or advance to an end point. There are the StartOf functions: Name Example Result StartOfYear (2020, 11, 13, 20, 30, 1) .StartOfYear() 2020/ 1/1 0:00:00:000 StartOfMonth (2020, 11, 13, 20, 30, 1) .StartOfMonth() 2020/11/ 1 0:00:00:000 StartOfDay (2020, 11, 13, 20, 30, 1) .StartOfDay() 2020/11/13 0:00:00:000 StartOfHour (2020, 11, 13, 20, 30, 1) .StartOfHour() 2020/11/13 20: 00:00:000 StartOfMinute (2020, 11, 13, 20, 30, 1) .StartOfMinute() 2020/11/13 20:30: 00:000 StartOfSecond (2020, 11, 13, 20, 30, 1) .StartOfSecond() 2020/11/13 20:30:01: 000 There are the EndOf functions: Name Example Result EndOfYear (2020, 11, 13, 20, 30, 1) .EndOfYear() 2020/ 12/31 23:59:59:999 EndOfMonth (2020, 11, 13, 20, 30, 1) .EndOfMonth() 2020/11/ 30 23:59:59:999 EndOfDay (2020, 11, 13, 20, 30, 1) .EndOfDay() 2020/11/13 23:59:59:999 EndOfHour (2020, 11, 13, 20, 30, 1) .EndOfHour() 2020/11/13 20: 59:59:999 EndOfMinute (2020, 11, 13, 20, 30, 1) .EndOfMinute() 2020/11/13 20:30: 59:999 EndOfSecond (2020, 11, 13, 20, 30, 1) .EndOfSecond() 2020/11/13 20:30:01: 999 Week Gets the number of weeks in a year for the specified date. /* 2020 - 01 * Su Mo Tu We Th Fr Sa *[ ( 1) 2 3 4 ] *[( 5) 6 7 8 9 10 11 ] * 12 13 14 15 16 17 18 * 19 20 21 22 23 24 25 * 26 27 28 29 30 31 */ Example Result (2020, 1, 1) .Week() 0 (2020, 1, 5) .Week() 1 WeekInMonth Gets the number of weeks in a month for the specified date. /* 2012 - 04 2012 - 04 * Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa * [ 1 [ 1] * 2 3 4 5 6] [ 7 8 [ 2 3 4 5 6 7 8] * 9 10 11 12 13] [14 15 [ 9 10 11 12 13 14 15] * (16) 17 18 19 20] [21 22 [(16) 17 18 19 20 21 22] * 23 24 25 26 27 28 29 23 24 25 26 27 28 29 * 30 30 */ Example Result (2012, 4, 16) .WeekInMonth ( DayOfWeek.Friday ) 2 (2012, 4, 16) .WeekInMonth ( DayOfWeek.Sunday ) 3 AddDays Provides a special arithmetic method for calculating working days or non-working days. public static DateTime AddDays(this DateTime @this, int value, DayMode mode) public enum DayMode { Undefined, Weekday, Weekend, } /* 2020 - 12 2020 - 12 * Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa * 1 2 3 4 5 * 6 7 8 9 10 11 12 * (13) 14 15 16 17 18 [19] * 20 [21] 22 23 24 25 26 * 27 28 29 30 31 */ Example Result (2020, 12, 13) .AddDays ( 6, DayMode.Weekday ) (2020, 12, 21) (2020, 12, 13) .AddDays ( 1, DayMode.Weekend ) (2020, 12, 19) AddTotalYears & AddTotalMonths AddTotalYears : Returns a new DateTime that adds the specified diff-number of years to the value of this instance. AddTotalMonths : Returns a new DateTime that adds the specified diff-number of months to the value of this instance. Example Result (2000, 2, 29) .AddTotalYears ( 1 ) (2001, 3, 1) (2001, 3, 1) .AddTotalYears ( -1 ) (2000, 3, 1) Elapsed... Gets the number of ... elapsed from DateTime.MinValue. Example Result (2012, 4, 16) .ElapsedDays ( ) 734608 (2012, 4, 16) .ElapsedMonths ( ) 24135.5"
  },
  "en/DpContainer.html": {
    "href": "en/DpContainer.html",
    "title": "| NStandard",
    "summary": "DpContainer DpContainer is used for dynamic programming calculations. Take the Fibonacci function as an example. Recursion Code int Fib(int n) { if (n == 0 || n == 1) return 1; else return Fib(n - 1) + Fib(n - 2); } void Main() { Fib(42).Dump(); } DP Code 1 (Using class) class DpFib : DpContainer<int, int> { public override int StateTransfer(int n) { if (n == 0 || n == 1) return 1; else return this[n - 1] + this[n - 2]; } } void Main() { var fib = new DpFib(); fib[42].Dump(); } DP Code 2 (Using function) int Fib(DefaultDpContainer<int, int> dp, int n) { if (n == 0 || n == 1) return 1; else return dp[n - 1] + dp[n - 2]; } void Main() { var fib = DpContainer.Create<int, int>(Fib); fib[42].Dump(); // same as Fib(fib, 42).Dump(); } The correct answer is 433494437. And the time required for the above code to get the correct result is roughly as follows: Name Elapsed Recursion Code about 3.823 seconds. * DP Code 1 (Using class) about 0.010 seconds. DP Code 2 (Using function) about 0.011 seconds."
  },
  "en/Evaluator.html": {
    "href": "en/Evaluator.html",
    "title": "| NStandard",
    "summary": "Numerical Evaluator NumericalEvaluator is used for parsing string expressions. For example: Evaluator.Numerical.Eval(\"2 >= 3 ? 5 : 7\"); The result is 7. We provide a rich set of operators: Priority Operator Description Example 1 ** Exponentiation. (2 ** 3) is 8. 3 // Floor division. (7 // 5) is 1. * Multiplication. (2 * 3) is 6. / Division. (7 / 5) is 1.4. % Modulus. (7 % 5) is 2. 4 + Addition. (2 + 3) is 5. - Subtraction. (7 - 5) is 2. 6 > Greater than. (7 > 5) is 1. >= Greater than or equal to. (7 >= 5) is 1. < Less than. (2 < 3) is 1. <= Less than or equal to. (2 <= 3) is 1. 7 == Equal. (7 == 7) is 1. != Not equal. (2 != 3) is 1. 11 and Returns the left-hand expression if the left-hand expression is 0, otherwise the right-hand expression. (3 and 5) is 5. (0 and 3) is 0. 12 or Returns the left-hand expression if the left-hand expression is not 0, otherwise the right-hand expression. (3 or 5) is 3. (0 or 3) is 3. 13 ?? Returns the right-hand expression if the left-hand expression is double.NaN, otherwise the left-hand expression. (5 ?? 7) is 5. (NaN ?? 7) is 7. 14 ? Returns the right-hand expression if the left-hand expression is not 0, otherwise double.NaN. (2 > 3 ? 5) is NaN. (2 < 3 ? 5) is 5. 15 : Returns the right-hand expression if the left-hand expression is double.NaN, otherwise the left-hand expression. (2 > 3 ? 5 : 7) is 7. (2 < 3 ? 5 : 7) is 5. The built-in UnaryOpFunctions: Operator Description Example not For an operation of the form !x. not 0 = 1 + For an operation of the form +x. + ( 2 + 3 ) = 5 - For an operation of the form –x. - ( 2 + 3 ) = -5 The built-in BracketFunctions: Operator Description Example ( ... ) High priority operation. 2 * ( 3 + 5 ) = 16 abs( ... ) Returns the absolute value of a double-precision floating-point number. abs(-2) = 2 sqrt( ... ) Returns the square root of a specified number. sqrt(9) = 3 ceil( ... ) Returns the smallest integral value that is greater than or equal to the specified double-precision floating-point number. ceil(6.8) = 7 floor( ... ) Returns the largest integer less than or equal to the specified double-precision floating-point number. floor(6.8) = 6 sin( ... ) Returns the sine of the specified angle. sin({Math.PI / 2}) = 1 cos( ... ) Returns the cosine of the specified angle. cos(0) = 1 tan( ... ) Returns the tangent of the specified angle. tan({Math.PI / 4}) = 1 asin( ... ) Returns the angle whose sine is the specified number. sin(1) = {Math.PI / 2} acos( ... ) Returns the angle whose cosine is the specified number. acos(1) = 0 atan( ... ) Returns the angle whose tangent is the specified number. atan(1) = {Math.PI / 4} sinh( ... ) Returns the hyperbolic sine of the specified angle. sinh(0.1) = 0.1001... cosh( ... ) Returns the hyperbolic cosine of the specified angle. cosh(0.1) = 1.0050... tanh( ... ) Returns the hyperbolic tangent of the specified angle. tanh(0.1) = 0.0996... If there are no parameters: Evaluator.Numerical.Eval(\"2 >= 3 ? 5 : 7\"); or there is any parameters: var exp = \"${price} >= 100 ? ${price} * 0.8 : ${price}\"; var func = Evaluator.Numerical.Compile(exp); var result = func(new { Price = 100 }); // The result is 80. var exp = \"${price} >= 100 ? ${price} * 0.8 : ${price}\"; var func = Evaluator.Numerical.Compile(exp); var result = func(new Dictionary<string, double> { [\"price\"] = 100 }); // The result is 80. class Item { public double Price { get; set; } } void Main() { var exp = \"${price} >= 100 ? ${price} * 0.8 : ${price}\"; var func = Evaluator.Numerical.Compile<Item>(exp); var result = func(new Item { Price = 100 }); // The result is 80. } It's worth noting that, these operators ( ? and : ) are specific. Used in combination, it will have the same effect as the ternary operator ( ? : ). Compilation phase For example, parse the string into a function. var exp = \"${x} + sqrt(abs(${x} * 3)) * 3\"; Parse a string into a collection of nodes. Problem NodeType Index Value Parameter 0 ${x} Ambiguity UnaryOperator, BinaryOperator 5 + StartBracket 7 sqrt( StartBracket 12 abs( Parameter 16 ${x} BinaryOperator 21 * Operand 23 3 EndBracket 24 ) EndBracket 25 ) BinaryOperator 27 * Operand 29 3 Disambiguate nodes. NodeType Index Value Parameter 0 ${x} BinaryOperator 5 + StartBracket 7 sqrt( StartBracket 12 abs( Parameter 16 ${x} BinaryOperator 21 * Operand 23 3 EndBracket 24 ) EndBracket 25 ) BinaryOperator 27 * Operand 29 3 Build the Expression. ( IIF(p.ContainsKey(\"x\"), p.get_Item(\"x\"), 0) + ( value(NStandard.Evaluators.NumericalEvaluator).Bracket ( \"sqrt(\", \")\", value(NStandard.Evaluators.NumericalEvaluator).Bracket ( \"abs(\", \")\", ( IIF(p.ContainsKey(\"x\"), p.get_Item(\"x\"), 0) * 3 ) ) ) * 3 ) ) Compile the Expression to Func<object, double>. var func = Evaluator.Numerical.Compile(exp); Call the Func<object, double>. Use anonymous object: var result = func(new { x = -3 }); or Dictionary<string, double>: var result = func(new Dictionary<string, double> { [\"x\"] = -3 }); Customize evaluator There is a simple evaluator which extend NumericalEvaluator: public class MyEvaluator : NumericalEvaluator { public MyEvaluator() { Define(\"!\", value => value != 0d ? 0d : 1d); DefineBracket(new(\"|\", \"|\"), value => Math.Abs(value)); Initialize(); } } Use | ... | to calculate the absolute value of a number. Use ! to invert a boolean. Note Calling the Initialize method in the constructor can give better performance for the first operation. Let's evaluate the string: \"|-9| + !0\" var evaluator = new MyEvaluator(); var result = evaluator.Eval(\"|-9| + !0\"); // |-9| is abs(-9) = 9 // !0 is 1 // The result is 10."
  },
  "en/SequenceInputStream.html": {
    "href": "en/SequenceInputStream.html",
    "title": "| NStandard",
    "summary": "SequenceInputStream SequenceInputStream can combine multiple streams into a single stream. Example using var stream = new SequenceInputStream( new MemoryStream(\"123\".Bytes(Encoding.UTF8)), new MemoryStream(\"456\".Bytes(Encoding.UTF8)), new MemoryStream(\"789\".Bytes(Encoding.UTF8)) ); using var reader = new StreamReader(stream); var result = reader.ReadToEnd(); // 123456789"
  },
  "en/State.html": {
    "href": "en/State.html",
    "title": "| NStandard",
    "summary": "State State is used for data binding. For example, there are two variables a b of type State<int>. using var a = State.Use(2); using var b = State.Use(3); and a variable c which is automatically calculated by a + b. using var c = State.From(() => a + b); // c.Value is 5。 Console.WriteLine(c.Value); When any Value of a b is changed, the value of c will be changed according to the formula at the same time. a.Value = 7; // c.Value is 10。 Console.WriteLine(c.Value); Implementation State collects dependencies at creation time and binds a notification function for each dependency. Subsequently, if the value of the dependency changes, the target State object is notified to set an expiration for the current value. When the State object gets the value, if the current value has expired, the latest value will be recalculated and cached. In general, State should be used together with using to avoid possible memory leaks. But this is not necessary, you can still improve performance through manual management, especially for a large number of State object management. Let's use an example to illustrate how State works. Define variables a b: using var a = State.Use(2); using var b = State.Use(3); Define variable c with value a + b. (This operation will also subscribe to notification events for a b.) var c = State.From(() => a + b); Get the value of c and output it. (The operation will evaluate the formula and cache the result.) Console.WriteLine(c.Value); Change the value of a to 7. (This operation will set the c value to Expired.) a.Value = 7; Retrieve the value of c and output it. (This operation will recalculate the formula and cache the result.) Console.WriteLine(c.Value); Dispose c. (The operation will unsubscribe from its dependencies' notification events.) c.Dispose(); Avoid memory leaks Consider the following example: root is a static State object. Array of State objects in member functions, dependent on root. Because these State objects are subscribed to static State update notifications, they will not be recycled when the function lifetime ends. To avoid memory leaks, using should be used or Dispose should be called manually. Calling the Release method of the subscriber to cancel all subscriptions that depend on the object can also avoid memory leaks, and the execution efficiency is higher. class Program { static State<int> root = State.Use(1); static void Main(string[] args) { PrintMemory(\"Beginning:\"); MakeSomeStateObjects(1_000); PrintMemory(\"Before release:\"); root.Release(); PrintMemory(\"After release:\"); } static void MakeSomeStateObjects(int count) { var States = new State<int>[count]; for (int i = 0; i < count; i++) { var index = i; States[i] = State.From(() => root + index); } //States.DisposeAll(); } static void PrintMemory(string title) { Console.WriteLine($\"{title，-38}{GC.GetTotalMemory(true) / 1024:N0} KB\"); } } Beginning: 504 KB Before release: 2,018 KB After release: 533 KB Optional events Event Signature Description Changed void Changed (TValue value) Fired when the value is explicitly changed. Updating void Updating (TValue value) Fired when the value is set to expire."
  },
  "en/UnitValue.html": {
    "href": "en/UnitValue.html",
    "title": "| NStandard",
    "summary": "UnitValue UnitValue is used to perform numeric operations with units. For example, the StorageValue is a data structure implemented based on IUnitValue: var a = StorageValue.Parse(\".5 MB\"); var b = new StorageValue(512, \"KB\"); var c = a + b; var mb = c.GetValue(\"MB\"); // 1 var kb = c.GetValue(\"KB\"); // 1024 Support mathematical operations: addition (+) a + b subtraction (-) a - b multiplication (*) a * 2 division (/) a / 2 comparison ( ==, !=, <, <=, >, >= ) a == b a != b a < b a <= b a > b a >= b Add up multiple values Constructing complex structures is a relatively time-consuming operation. So, it doesn't make sense to add up each number in turn. We provide a more efficient way (using QuickSum function) to handle this situation. For example, there are many StorageValues: var values = new StorageValue[100_000_000].Let(i => new StorageValue(i)); then, to calculate their sum: ✔️ CONSIDER (about 1.00 seconds) var sum = new StorageValue(); sum.QuickSum(values); ❌ AVOID (about 4.00 seconds) var sum = new StorageValue(); foreach (var value in values) { sum += value; } Using LinqSharp ✔️ CONSIDER (about 1.00 seconds) var sum = values.QSum(); ❌ AVOID (about 4.00 seconds) var sum = values.Sum();"
  },
  "en/field-feature.html": {
    "href": "en/field-feature.html",
    "title": "Field Feature | NStandard",
    "summary": "Field Feature Auto properties only allow for directly setting or getting the backing field, giving some control only by placing access modifiers on the accessors. Sometimes there is a need to have additional control over what happens in one or both accessors, but this confronts users with the overhead of declaring a backing field. The backing field name must then be kept in sync with the property, and the backing field is scoped to the entire class which can result in accidental bypassing of the accessors from within the class. This is the one of implementation: public partial class LegacyModel { private int _number; public int Number { get => _number; set => _number = value; } private int[] _numbers; public int[] Numbers { get => _numbers; set => _numbers = value; } } However, we hope to avoid manually declaring backing fields for older projects. Use FieldFeature to enable the generator to analyze the code of a class or struct, and use FieldBackend to hide the backing fields: [FieldFeature] public partial class Model { [FieldBackend] public int Number { get => GetValue(); set => SetValue(value); } [FieldBackend] public int[] Numbers { get => GetValue(); set => SetValue(value); } } .NET 10 (C# 14) added the field keyword to handle this situation. public class Model { public int Number { get => field; set => field = value; } public int[] Numbers { get => field; set => field = value; } }"
  },
  "en/getting-started.html": {
    "href": "en/getting-started.html",
    "title": "Getting Started | NStandard",
    "summary": "Getting Started"
  },
  "en/introduction.html": {
    "href": "en/introduction.html",
    "title": "Introduction | NStandard",
    "summary": "Introduction"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | NStandard",
    "summary": "This is the HOMEPAGE. Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  }
}