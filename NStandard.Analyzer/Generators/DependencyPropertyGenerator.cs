using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NStandard.Analyzer.Generators;

[Generator]
public class DependencyPropertyGenerator : ISourceGenerator
{
    private readonly TypeDetector _typeDetector = new();

    public void Initialize(GeneratorInitializationContext context)
    {
#if DEBUG
        // if (!Debugger.IsAttached) Debugger.Launch();
#endif
    }

    private class DependencyProperty
    {
        public TypeSymbol Symbol { get; set; }
        public string Modifier { get; set; }
        public string Type { get; set; }
        public string Name { get; set; }
        public bool HasChangedCallback { get; set; }
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var usings = new HashSet<string>()
        {
            "System",
            "System.Windows",
        };
        var list = new List<DependencyProperty>();

        var syntaxTrees = context.Compilation.SyntaxTrees;
        foreach (var tree in syntaxTrees)
        {
            var semantic = context.Compilation.GetSemanticModel(tree);
            var namespaces = tree.GetRoot()
                .DescendantNodesAndSelf()
                .OfType<BaseNamespaceDeclarationSyntax>();

            if (!namespaces.Any()) continue;

            foreach (var ns in namespaces)
            {
                var nsName = ns.Name.ToString();
                var classes = ns.DescendantNodes().OfType<ClassDeclarationSyntax>();

                foreach (var _class in classes)
                {
                    var name = _class.Identifier.Text;
                    var symbol = _typeDetector.GetSymbol(ns.Name.ToString(), _class);

                    var methods = _class.ChildNodes().OfType<MethodDeclarationSyntax>();
                    var props = _class.ChildNodes().OfType<PropertyDeclarationSyntax>();
                    foreach (var prop in props)
                    {
                        var attributes = prop.AttributeLists.SelectMany(x => x.Attributes);
                        foreach (var attr in attributes)
                        {
                            var attrType = semantic.GetTypeInfo(attr);
                            if (attrType.ConvertedType!.ToString() == "NStandard.Xaml.ComponentModel.DependencyPropertyAttribute")
                            {
                                var hasChangedCallback = methods.Any(x => x.Identifier.Text == $"{prop.Identifier.Text}_OnChanged");
                                var propType = semantic.GetTypeInfo(prop.Type);
                                usings.Add(propType.ConvertedType!.ContainingNamespace.ToString());

                                list.Add(new()
                                {
                                    Symbol = symbol,
                                    Modifier = prop.Modifiers.ToString(),
                                    Type = prop.Type!.ToString(),
                                    Name = prop.Identifier.Text,
                                    HasChangedCallback = hasChangedCallback,
                                });
                            }
                        }
                    }
                }
            }
        }

        foreach (var g in list.GroupBy(x => x.Symbol))
        {
            var builder = new StringBuilder();

            builder.AppendLine("// <auto-generated/>");
            foreach (var ns in usings.OrderBy(x => x))
            {
                builder.AppendLine($"using {ns};");
            }
            builder.AppendLine();

            builder.AppendLine($"""
            namespace {g.Key.Namespace}
            {"{"}
                public partial class {g.Key.Name}
                {"{"}
            """);

            foreach (var prop in g)
            {
                var property = $"{prop.Name}Property";
                builder.AppendLine($"""
                        public static readonly DependencyProperty {property} = DependencyProperty.Register("{prop.Name}", typeof({prop.Type}), typeof({g.Key.Name}){(prop.HasChangedCallback ? $"""
                        , new()
                        {"{"}
                            PropertyChangedCallback = (d, e) =>
                            {"{"}
                                {prop.Name}_OnChanged(({g.Key.Name})d, ({prop.Type})e.NewValue);
                            {"}"},
                        {"}"}
                """ : "")});
                        public partial {prop.Type} {prop.Name}
                        {"{"}
                            get => ({prop.Type})GetValue({property});
                            set => SetValue({property}, value);
                        {"}"}
                """);
            }

            builder.AppendLine($"""
                {"}"}
            {"}"}
            """);
            context.AddSource($"{g.Key}.g.cs", builder.ToString());
        }
    }
}
