using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using NStandard.Analyzer.Extensions;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NStandard.Analyzer.Generators;

[Generator]
public class DependencyPropertyFeatureGenerator : IIncrementalGenerator
{
    public const string FeatureAttributeName = "NStandard.ComponentModel.DependencyPropertyFeatureAttribute";
    private readonly TypeDetector _typeDetector = new();

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        //if (!System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Launch();
#endif
        var provider = context.SyntaxProvider
            .ForAttributeWithMetadataName(FeatureAttributeName,
                static (node, _) => node is ClassDeclarationSyntax,
                static (ctx, _) => (ctx.TargetNode as ClassDeclarationSyntax)!
            );
        var compilation = context.CompilationProvider.Combine(provider.Collect());
        context.RegisterSourceOutput(compilation, Execute);
    }

    private class DependencyProperty
    {
        public TypeSymbol Symbol { get; set; }
        public string Modifier { get; set; }
        public string Type { get; set; }
        public string Name { get; set; }
        public bool HasChangedCallback { get; set; }
    }

    public void Execute(SourceProductionContext context, (Compilation, ImmutableArray<ClassDeclarationSyntax>) tuple)
    {
        var (compilation, nodes) = tuple;
        if (nodes.Length == 0) return;

        var usings = new HashSet<string>()
        {
            "System",
            "System.Windows",
        };
        var list = new List<DependencyProperty>();

        foreach (var typeDeclaration in nodes)
        {
            var semantic = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            var symbol = _typeDetector.GetSymbol(compilation, typeDeclaration);
            var methods = typeDeclaration.ChildNodes().OfType<MethodDeclarationSyntax>();
            var props = typeDeclaration.ChildNodes().OfType<PropertyDeclarationSyntax>();
            foreach (var prop in props)
            {
                var attributes = prop.AttributeLists.SelectMany(x => x.Attributes);
                foreach (var attr in attributes)
                {
                    var attrType = semantic.GetTypeInfo(attr);
                    if (attrType.ConvertedType!.ToString() == "NStandard.ComponentModel.DependencyPropertyAttribute")
                    {
                        var hasChangedCallback = methods.Any(x => x.Identifier.Text == $"{prop.Identifier.Text}_OnChanged");
                        var propType = semantic.GetTypeInfo(prop.Type);
                        var propNamespaces = propType.ConvertedType!.GetUsingNamespaces();
                        foreach (var _ns in propNamespaces)
                        {
                            usings.Add(_ns.ToDisplayString());
                        }

                        list.Add(new()
                        {
                            Symbol = symbol,
                            Modifier = prop.Modifiers.ToString(),
                            Type = prop.Type!.ToString(),
                            Name = prop.Identifier.Text,
                            HasChangedCallback = hasChangedCallback,
                        });
                    }
                }
            }
        }

        foreach (var g in list.GroupBy(x => x.Symbol))
        {
            var builder = new StringBuilder();

            builder.AppendLine("// <auto-generated/>");
            foreach (var ns in usings.OrderBy(x => x))
            {
                builder.AppendLine($"using {ns};");
            }
            builder.AppendLine();

            builder.AppendLine($"""
            namespace {g.Key.Namespace}
            {"{"}
                public partial class {g.Key.Name}
                {"{"}
            """);

            foreach (var prop in g)
            {
                var property = $"{prop.Name}Property";
                builder.Append($"""
                        public static readonly DependencyProperty {property} = DependencyProperty.Register("{prop.Name}", typeof({prop.Type}), typeof({g.Key.Name})
                """);
                if (prop.HasChangedCallback)
                {
                    builder.AppendLine($"""
                    , new()
                            {"{"}
                                PropertyChangedCallback = (d, e) =>
                                {"{"}
                                    {prop.Name}_OnChanged(({g.Key.Name})d, ({prop.Type})e.NewValue);
                                {"}"},
                            {"}"}
                    """);
                }
                builder.AppendLine(");");

                builder.AppendLine($"""
                        public partial {prop.Type} {prop.Name}
                        {"{"}
                            get => ({prop.Type})GetValue({property});
                            set => SetValue({property}, value);
                        {"}"}
                """);
            }

            builder.AppendLine($"""
                {"}"}
            {"}"}
            """);
            context.AddSource($"{g.Key}.g.cs", builder.ToString());
        }
    }
}
