using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using NStandard.Analyzer.Extensions;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NStandard.Analyzer.Generators;

[Generator]
public class FieldFeatureGenerator : IIncrementalGenerator
{
    public const string FeatureAttributeName = "NStandard.Design.FieldFeatureAttribute";
    private readonly TypeDetector _typeDetector = new();

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        //if (!System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Launch();
#endif
        var provider = context.SyntaxProvider
            .ForAttributeWithMetadataName(FeatureAttributeName,
                static (node, _) => node is TypeDeclarationSyntax,
                static (ctx, _) => (ctx.TargetNode as TypeDeclarationSyntax)!
            );
        var compilation = context.CompilationProvider.Combine(provider.Collect());
        context.RegisterSourceOutput(compilation, Execute);
    }

    private class Field
    {
        public TypeSymbol Symbol { get; set; }
        public string Modifier { get; set; }
        public string Type { get; set; }
        public string Name { get; set; }
        public object DefaultValue { get; set; }
    }

    public void Execute(SourceProductionContext context, (Compilation, ImmutableArray<TypeDeclarationSyntax>) tuple)
    {
        var (compilation, nodes) = tuple;
        if (nodes.Length == 0) return;

        var usings = new HashSet<string>()
        {
            "System",
            "System.Runtime.CompilerServices",
        };
        var list = new List<Field>();

        foreach (var typeDeclaration in nodes)
        {
            var semantic = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            var symbol = _typeDetector.GetSymbol(compilation, typeDeclaration);
            var props = typeDeclaration.ChildNodes().OfType<PropertyDeclarationSyntax>();
            var typeAttributes = typeDeclaration.AttributeLists.SelectMany(x => x.Attributes);

            foreach (var prop in props)
            {
                var attributes = prop.AttributeLists.SelectMany(x => x.Attributes);
                foreach (var attr in attributes)
                {
                    var attrType = semantic.GetTypeInfo(attr);
                    if (attrType.ConvertedType!.ToDisplayString() == "NStandard.Design.FieldBackendAttribute")
                    {
                        var propType = semantic.GetTypeInfo(prop.Type);
                        var propNamespaces = propType.ConvertedType!.GetUsingNamespaces();
                        foreach (var _ns in propNamespaces)
                        {
                            usings.Add(_ns.ToDisplayString());
                        }

                        list.Add(new()
                        {
                            Symbol = symbol,
                            Modifier = prop.Modifiers.ToString(),
                            Type = prop.Type!.ToString(),
                            Name = prop.Identifier.Text,
                        });
                    }
                }
            }
        }

        foreach (var g in list.GroupBy(x => x.Symbol))
        {
            var builder = new StringBuilder();

            builder.AppendLine("// <auto-generated/>");
            foreach (var ns in usings.OrderBy(x => x))
            {
                builder.AppendLine($"using {ns};");
            }
            builder.AppendLine();

            var code = new StringBuilder();
            code.AppendLine($"""
            public struct Fields
            {"{"}
            """);
            foreach (var prop in g)
            {
                code.AppendLine($"""
                    public {prop.Type} {prop.Name} {"{"} get; set; {"}"}
                """);
            }
            code.AppendLine($"""
            {"}"}
            private Fields fields;
            """);

            code.AppendLine();

            code.AppendLine($"""
            public dynamic? GetValue([CallerMemberName] string name = "")
            {"{"}
                return name switch
                {"{"}
            """);
            foreach (var prop in g)
            {
                code.AppendLine($"""
                        nameof({prop.Name}) => fields.{prop.Name},
                """);
            }
            code.AppendLine($"""
                    _ => throw new NotImplementedException($"FieldContainer.GetValue: {"{"}name{"}"} is not implemented."),
                {"}"};
            {"}"}
            public void SetValue(dynamic? value, [CallerMemberName] string name = "")
            {"{"}
                switch (name)
                {"{"}
            """);
            foreach (var prop in g)
            {
                var property = $"{prop.Name}Property";
                code.AppendLine($"""
                        case nameof({prop.Name}): fields.{prop.Name} = value; break;
                """);
            }
            code.AppendLine($"""
                    default: throw new NotImplementedException($"FieldContainer.SetValue: {"{"}name{"}"} is not implemented.");
                {"}"}
            {"}"}
            """);

            builder.AppendLine(g.Key.Format(code.ToString()));
            context.AddSource($"{g.Key}.g.cs", builder.ToString());
        }
    }
}
