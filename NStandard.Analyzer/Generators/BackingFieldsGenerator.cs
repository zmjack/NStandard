using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NStandard.Analyzer.Generators;

[Generator]
public class BackingFieldsGenerator : ISourceGenerator
{
    private readonly TypeDetector _typeDetector = new();

    public void Initialize(GeneratorInitializationContext context)
    {
#if DEBUG
        // if (!Debugger.IsAttached) Debugger.Launch();
#endif
    }

    private class Field
    {
        public TypeSymbol Symbol { get; set; }
        public string Modifier { get; set; }
        public string Type { get; set; }
        public string Name { get; set; }
        public object DefaultValue { get; set; }
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var usings = new HashSet<string>()
        {
            "System",
            "System.Runtime.CompilerServices",
        };
        var list = new List<Field>();

        var syntaxTrees = context.Compilation.SyntaxTrees;
        foreach (var tree in syntaxTrees)
        {
            var semantic = context.Compilation.GetSemanticModel(tree);
            var namespaces = tree.GetRoot()
                .DescendantNodesAndSelf()
                .OfType<BaseNamespaceDeclarationSyntax>();

            if (!namespaces.Any()) continue;

            foreach (var ns in namespaces)
            {
                var nsName = ns.Name.ToString();
                var typeDeclarations = ns.DescendantNodes().OfType<TypeDeclarationSyntax>();

                foreach (var typeDeclaration in typeDeclarations)
                {
                    var name = typeDeclaration.Identifier.Text;
                    TypeSymbol? symbol = _typeDetector.GetSymbol(ns.Name.ToString(), typeDeclaration);

                    var methods = typeDeclaration.DescendantNodes().OfType<MethodDeclarationSyntax>();
                    var props = typeDeclaration.ChildNodes().OfType<PropertyDeclarationSyntax>();
                    foreach (var prop in props)
                    {
                        var attributes = prop.AttributeLists.SelectMany(x => x.Attributes);
                        foreach (var attr in attributes)
                        {
                            var attrType = semantic.GetTypeInfo(attr);
                            if (attrType.ConvertedType!.ToString() == "NStandard.Design.FieldBackendAttribute")
                            {
                                var propType = semantic.GetTypeInfo(prop.Type);
                                usings.Add(propType.ConvertedType!.ContainingNamespace.ToString());

                                list.Add(new()
                                {
                                    Symbol = symbol,
                                    Modifier = prop.Modifiers.ToString(),
                                    Type = prop.Type!.ToString(),
                                    Name = prop.Identifier.Text,
                                });
                            }
                        }
                    }
                }
            }
        }

        foreach (var g in list.GroupBy(x => x.Symbol))
        {
            var builder = new StringBuilder();

            builder.AppendLine("// <auto-generated/>");
            foreach (var ns in usings.OrderBy(x => x))
            {
                builder.AppendLine($"using {ns};");
            }
            builder.AppendLine();

            var code = new StringBuilder();
            code.AppendLine($"""
            public struct Fields
            {"{"}
            """);
            foreach (var prop in g)
            {
                code.AppendLine($"""
                    public {prop.Type} {prop.Name} {"{"} get; set; {"}"}
                """);
            }
            code.AppendLine($"""
            {"}"}
            private Fields fields = new Fields();
            """);

            code.AppendLine();

            code.AppendLine($"""
            public dynamic? GetValue([CallerMemberName] string name = "")
            {"{"}
                return name switch
                {"{"}
            """);
            foreach (var prop in g)
            {
                code.AppendLine($"""
                        nameof({prop.Name}) => fields.{prop.Name},
                """);
            }
            code.AppendLine($"""
                    _ => throw new NotImplementedException($"FieldContainer.GetValue: {"{"}name{"}"} is not implemented."),
                {"}"};
            {"}"}
            public void SetValue(dynamic? value, [CallerMemberName] string name = "")
            {"{"}
                switch (name)
                {"{"}
            """);
            foreach (var prop in g)
            {
                var property = $"{prop.Name}Property";
                code.AppendLine($"""
                        case nameof({prop.Name}): fields.{prop.Name} = value; break;
                """);
            }
            code.AppendLine($"""
                    default: throw new NotImplementedException($"FieldContainer.SetValue: {"{"}name{"}"} is not implemented.");
                {"}"}
            {"}"}
            """);

            builder.AppendLine(g.Key.Format(code.ToString()));
            context.AddSource($"{g.Key}.g.cs", builder.ToString());
        }
    }
}
